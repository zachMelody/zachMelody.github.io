<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>二分查找 | 旋律小站</title><meta name=keywords content><meta name=description content="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/
 阅读提示：内容比较多，核心思想帮大家归纳一下。如果没有时间看，建议把后面的问题做一下。
 题解核心内容：所有模板都一样，不可以套模板，而应该 仔细看题（解题的关键在认真读题），分析清楚题目要找的答案需要满足什么性质。采用两边夹的方式，每一轮把待搜索区间分成两个部分，排除掉一定不是答案的区间，最后左右指针重合的地方就是我们要找的元素。
 说明：我所有的关于「二分查找」法的题解，都会明确地标注「下一轮搜索区间是什么」，进而设置左边界 left 和 右边界 right。在我写的「二分查找」题解里，while(left < right) 不表示 循环不变量的区间定义是 [left..right)，也就是说，如果我分析出，下一轮搜索区间是 [mid..10]，我会设置 right = 10，而不会设置 right = 11。
如果你看我写的「二分查找」题解，请忘记掉「左闭右开」这件事情，它会对你有所干扰。
二分查找只有一个思想，那就是：逐步缩小搜索区间。
 本题解向大家介绍的，使用 left 和 right 向中间靠拢的方法，有一个非常强的语义，那就是：当 left与right 重合的时候，我们就找到了问题的答案，使用这种写法有一个巨大的好处，那就是返回值不需要考虑返回 left 还是 right，因为退出循环以后，它们是重合的。
  在做题的过程中，会遇到两个难点：1、取 mid 的时候，有些时候需要 +1，这是因为需要避免死循环；2、只把区间分成两个部分，这是因为：只有这样，退出循环的时候才有 left 与 right 重合，我们才敢说，找到了问题的答案。（这两个难点，在练习的过程中，会逐渐清晰，不用着急一下子搞懂，事实上并不难理解）。
  第一部分：本题题解  这一部分一定要分析清楚：
  题目要找的元素是：第一个大于等于 target 的元素的下标； 数组的长度 len 也有可能是问题的答案，「参考代码 2」设置 right = len 不是因为设置区间是「左闭右开」，而是因为 len 本来就有可能是问题的答案。   上面 2 个小点，都需要仔细分析题意和几个示例得到，任何模板都不能回答这样的问题。"><meta name=author content="Me"><link rel=canonical href=https://zachmelody.github.io/posts/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=preload href=/%e5%ad%a6%e5%8e%86.svg as=image><link rel=icon href=https://zachmelody.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://zachmelody.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://zachmelody.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://zachmelody.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://zachmelody.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.96.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="二分查找"><meta property="og:description" content="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/
 阅读提示：内容比较多，核心思想帮大家归纳一下。如果没有时间看，建议把后面的问题做一下。
 题解核心内容：所有模板都一样，不可以套模板，而应该 仔细看题（解题的关键在认真读题），分析清楚题目要找的答案需要满足什么性质。采用两边夹的方式，每一轮把待搜索区间分成两个部分，排除掉一定不是答案的区间，最后左右指针重合的地方就是我们要找的元素。
 说明：我所有的关于「二分查找」法的题解，都会明确地标注「下一轮搜索区间是什么」，进而设置左边界 left 和 右边界 right。在我写的「二分查找」题解里，while(left < right) 不表示 循环不变量的区间定义是 [left..right)，也就是说，如果我分析出，下一轮搜索区间是 [mid..10]，我会设置 right = 10，而不会设置 right = 11。
如果你看我写的「二分查找」题解，请忘记掉「左闭右开」这件事情，它会对你有所干扰。
二分查找只有一个思想，那就是：逐步缩小搜索区间。
 本题解向大家介绍的，使用 left 和 right 向中间靠拢的方法，有一个非常强的语义，那就是：当 left与right 重合的时候，我们就找到了问题的答案，使用这种写法有一个巨大的好处，那就是返回值不需要考虑返回 left 还是 right，因为退出循环以后，它们是重合的。
  在做题的过程中，会遇到两个难点：1、取 mid 的时候，有些时候需要 +1，这是因为需要避免死循环；2、只把区间分成两个部分，这是因为：只有这样，退出循环的时候才有 left 与 right 重合，我们才敢说，找到了问题的答案。（这两个难点，在练习的过程中，会逐渐清晰，不用着急一下子搞懂，事实上并不难理解）。
  第一部分：本题题解  这一部分一定要分析清楚：
  题目要找的元素是：第一个大于等于 target 的元素的下标； 数组的长度 len 也有可能是问题的答案，「参考代码 2」设置 right = len 不是因为设置区间是「左闭右开」，而是因为 len 本来就有可能是问题的答案。   上面 2 个小点，都需要仔细分析题意和几个示例得到，任何模板都不能回答这样的问题。"><meta property="og:type" content="article"><meta property="og:url" content="https://zachmelody.github.io/posts/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"><meta property="og:image" content="https://zachmelody.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-16T15:58:36+08:00"><meta property="article:modified_time" content="2022-03-16T15:58:36+08:00"><meta property="og:site_name" content="旋律小站"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zachmelody.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="二分查找"><meta name=twitter:description content="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/
 阅读提示：内容比较多，核心思想帮大家归纳一下。如果没有时间看，建议把后面的问题做一下。
 题解核心内容：所有模板都一样，不可以套模板，而应该 仔细看题（解题的关键在认真读题），分析清楚题目要找的答案需要满足什么性质。采用两边夹的方式，每一轮把待搜索区间分成两个部分，排除掉一定不是答案的区间，最后左右指针重合的地方就是我们要找的元素。
 说明：我所有的关于「二分查找」法的题解，都会明确地标注「下一轮搜索区间是什么」，进而设置左边界 left 和 右边界 right。在我写的「二分查找」题解里，while(left < right) 不表示 循环不变量的区间定义是 [left..right)，也就是说，如果我分析出，下一轮搜索区间是 [mid..10]，我会设置 right = 10，而不会设置 right = 11。
如果你看我写的「二分查找」题解，请忘记掉「左闭右开」这件事情，它会对你有所干扰。
二分查找只有一个思想，那就是：逐步缩小搜索区间。
 本题解向大家介绍的，使用 left 和 right 向中间靠拢的方法，有一个非常强的语义，那就是：当 left与right 重合的时候，我们就找到了问题的答案，使用这种写法有一个巨大的好处，那就是返回值不需要考虑返回 left 还是 right，因为退出循环以后，它们是重合的。
  在做题的过程中，会遇到两个难点：1、取 mid 的时候，有些时候需要 +1，这是因为需要避免死循环；2、只把区间分成两个部分，这是因为：只有这样，退出循环的时候才有 left 与 right 重合，我们才敢说，找到了问题的答案。（这两个难点，在练习的过程中，会逐渐清晰，不用着急一下子搞懂，事实上并不难理解）。
  第一部分：本题题解  这一部分一定要分析清楚：
  题目要找的元素是：第一个大于等于 target 的元素的下标； 数组的长度 len 也有可能是问题的答案，「参考代码 2」设置 right = len 不是因为设置区间是「左闭右开」，而是因为 len 本来就有可能是问题的答案。   上面 2 个小点，都需要仔细分析题意和几个示例得到，任何模板都不能回答这样的问题。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zachmelody.github.io/posts/"},{"@type":"ListItem","position":2,"name":"二分查找","item":"https://zachmelody.github.io/posts/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"二分查找","name":"二分查找","description":"https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/\n 阅读提示：内容比较多，核心思想帮大家归纳一下。如果没有时间看，建议把后面的问题做一下。\n 题解核心内容：所有模板都一样，不可以套模板，而应该 仔细看题（解题的关键在认真读题），分析清楚题目要找的答案需要满足什么性质。采用两边夹的方式，每一轮把待搜索区间分成两个部分，排除掉一定不是答案的区间，最后左右指针重合的地方就是我们要找的元素。\n 说明：我所有的关于「二分查找」法的题解，都会明确地标注「下一轮搜索区间是什么」，进而设置左边界 left 和 右边界 right。在我写的「二分查找」题解里，while(left \u0026lt; right) 不表示 循环不变量的区间定义是 [left..right)，也就是说，如果我分析出，下一轮搜索区间是 [mid..10]，我会设置 right = 10，而不会设置 right = 11。\n如果你看我写的「二分查找」题解，请忘记掉「左闭右开」这件事情，它会对你有所干扰。\n二分查找只有一个思想，那就是：逐步缩小搜索区间。\n 本题解向大家介绍的，使用 left 和 right 向中间靠拢的方法，有一个非常强的语义，那就是：当 left与right 重合的时候，我们就找到了问题的答案，使用这种写法有一个巨大的好处，那就是返回值不需要考虑返回 left 还是 right，因为退出循环以后，它们是重合的。\n  在做题的过程中，会遇到两个难点：1、取 mid 的时候，有些时候需要 +1，这是因为需要避免死循环；2、只把区间分成两个部分，这是因为：只有这样，退出循环的时候才有 left 与 right 重合，我们才敢说，找到了问题的答案。（这两个难点，在练习的过程中，会逐渐清晰，不用着急一下子搞懂，事实上并不难理解）。\n  第一部分：本题题解  这一部分一定要分析清楚：\n  题目要找的元素是：第一个大于等于 target 的元素的下标； 数组的长度 len 也有可能是问题的答案，「参考代码 2」设置 right = len 不是因为设置区间是「左闭右开」，而是因为 len 本来就有可能是问题的答案。   上面 2 个小点，都需要仔细分析题意和几个示例得到，任何模板都不能回答这样的问题。","keywords":[],"articleBody":" https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/\n 阅读提示：内容比较多，核心思想帮大家归纳一下。如果没有时间看，建议把后面的问题做一下。\n 题解核心内容：所有模板都一样，不可以套模板，而应该 仔细看题（解题的关键在认真读题），分析清楚题目要找的答案需要满足什么性质。采用两边夹的方式，每一轮把待搜索区间分成两个部分，排除掉一定不是答案的区间，最后左右指针重合的地方就是我们要找的元素。\n 说明：我所有的关于「二分查找」法的题解，都会明确地标注「下一轮搜索区间是什么」，进而设置左边界 left 和 右边界 right。在我写的「二分查找」题解里，while(left 不表示 循环不变量的区间定义是 [left..right)，也就是说，如果我分析出，下一轮搜索区间是 [mid..10]，我会设置 right = 10，而不会设置 right = 11。\n如果你看我写的「二分查找」题解，请忘记掉「左闭右开」这件事情，它会对你有所干扰。\n二分查找只有一个思想，那就是：逐步缩小搜索区间。\n 本题解向大家介绍的，使用 left 和 right 向中间靠拢的方法，有一个非常强的语义，那就是：当 left与right 重合的时候，我们就找到了问题的答案，使用这种写法有一个巨大的好处，那就是返回值不需要考虑返回 left 还是 right，因为退出循环以后，它们是重合的。\n  在做题的过程中，会遇到两个难点：1、取 mid 的时候，有些时候需要 +1，这是因为需要避免死循环；2、只把区间分成两个部分，这是因为：只有这样，退出循环的时候才有 left 与 right 重合，我们才敢说，找到了问题的答案。（这两个难点，在练习的过程中，会逐渐清晰，不用着急一下子搞懂，事实上并不难理解）。\n  第一部分：本题题解  这一部分一定要分析清楚：\n  题目要找的元素是：第一个大于等于 target 的元素的下标； 数组的长度 len 也有可能是问题的答案，「参考代码 2」设置 right = len 不是因为设置区间是「左闭右开」，而是因为 len 本来就有可能是问题的答案。   上面 2 个小点，都需要仔细分析题意和几个示例得到，任何模板都不能回答这样的问题。\n 题意分析 根据示例，分析题目要我们返回的「插入元素的位置」是什么。\n思路分析 在有序数组中查找，可以使用「二分查找」。\n根据「题意分析」中对示例的描述：\n 情况 1：如果当前 mid看到的数值严格小于target，那么 mid以及mid 左边的所有元素就一定不是「插入元素的位置」，因此下一轮搜索区间是 [mid + 1..right]，下一轮把 left 移动到 mid + 1 位置，因此设置 left = mid + 1； 情况 2：否则，如果 mid 看到的数值大于等于 target，那么 mid 可能是「插入元素的位置」，mid 的右边一定不存在「插入元素的位置」。如果 mid 的左边不存在「插入元素的位置」，我们才可以说 mid 是「插入元素的位置」。因此下一轮搜索区间是 [left..mid]，下一轮把 right 移动到 mid 位置，因此设置 right = mid。  说明：上面的两点中，「情况 2」其实不用分析得那么细致， 因为只要「情况 1」的区间分析是正确的，「情况 2」一定是「情况 1」得到的区间的反面区间。\n参考代码 1：\n Java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  public class Solution {   public int searchInsert(int[] nums, int target) {  int len = nums.length;  // 特殊判断  if (nums[len - 1]  return len;  }   // 程序走到这里一定有 nums[len - 1] = target，插入位置在区间 [.len - 1]  int left = 0;  int right = len - 1;  // 在区间 nums[left..right] 里查找第 1 个大于等于 target 的元素的下标  while (left  int mid = left + (right - left) / 2;  if (nums[mid]  // 下一轮搜索的区间是 [mid + .right]  left = mid + 1;  } else {  // 下一轮搜索的区间是 [left..mid]  right = mid;  }  }  return left;  } }   说明：while (left 表示当 left 与 right 重合的时候，搜索终止。根据题意和示例，区间 nums[left..right] 里一定存在「插入元素的位置」，且 while 循环里只把区间分成两个部分，退出循环的时候一定有 left == right 成立，因此返回 left 或者 right 都可以。\n复杂度分析：\n 时间复杂度：O(log⁡N)O(\\log N)O(logN)，这里 NNN 是输入数组的长度； 空间复杂度：O(1)O(1)O(1)。  既然 len 也有可能是答案，可以在初始化的时候，把 right 设置成 len，在一开始的时候就不需要特殊判断了。\n参考代码 2：\n Java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  public class Solution {   public int searchInsert(int[] nums, int target) {  int len = nums.length;  int left = 0;  int right = len;  // 在区间 nums[left..right] 里查找第 1 个大于等于 target 的元素的下标  while (left  int mid = left + (right - left) / 2;  if (nums[mid]  // 下一轮搜索的区间是 [mid + .right]  left = mid + 1;  } else {  // 下一轮搜索的区间是 [left..mid]  right = mid;  }  }  return left;  } }   复杂度分析：（同参考代码 1）\n 第二部分：二分查找常见问题回答 温馨提示：\n 以下内容有点多，但是都是非常简单直观的内容。我整理了在我的题解下网友的诸多疑问，进行了总结，希望大家能认真看看； 真的踏踏实实做完一些二分查找的问题，已经有了足够的思考，就会觉得没有那么难。  问题 1：为什么在你的题解里 while (left 表示左闭右闭区间 回答：看到 while (left 不表示搜索区间为「左闭右开」，这一点没有根据。真正应该看边界如何设置，这一点完全是人为定义。\n表示一个区间，最直接的表示就是左闭右闭区间。例如：我们想表示搜索的范围是\n1  1, 2, 3, 4, 5, 6, 7, 8, 9   ，很自然地会表示成 [1..9] ，我们也会说这些数是 1 到 9 之间的数，包括 1 和 9。正常情况下，不会说：这些数在 1 到 10 之间，不包括 10；\n只看到 while (left 里的  ，不能说明右边界不能取到。真正看区间表示应该看左右边界到底如何设置，如果我们分析出下一轮搜索的范围是 [left..mid] 而设置 right = mid + 1，才表示搜索区间为「左闭右开」区间 。这是因为\n1  [left..right) = [left..mid + 1) = [left..mid]   可以看到，任何一个「左闭右开」区间都对应一个「左闭右闭」区间。我们已经可以确切地知道要搜索的数的右边界是什么， 没有必要把右边界再 +1+1+1。\n重点：真正写对「二分查找」，从来不在于我们把区间写成了「左闭右开」还是「左闭右闭」，而是 在于我们能够根据题意：得到某种单调性，和可以逐步缩小搜索规模的条件，进而准确地设计可以使得搜索区间缩小的条件。\n问题 2：二分查找是不是要求数组一定是有序的？ 回答：不一定。\n「力扣」上有一些问题输入数组不是有序的，例如「旋转有序数组」「山脉数组」（题号在第三部分的习题列表里），这些问题题目给出的是「接近有序」的数组，依然可以使用「二分查找」，这是因为这些数组都有规律可循，可以根据看到的 num[mid] 的值，推测两侧元素的性质，进而 缩小搜索区间。\n还有一类问题，例如「力扣」第 287 题，这一类题目不是在输入数组上做二分，而是在输入数组的最小值 min 和最大值 max 组成的连续整数数组上查找一个数，即搜索区间是 [min..max]，这个区间是单调的。\n这一类问题的特点是：题目要我们找一个整数，这个整数的范围是确定的，可以使用「二分查找」，这样的问题叫「二分答案」。很多引入「二分查找」的例子，其实就是在做「二分答案」，《幸运 52》猜价格游戏，就是在用「二分查找」的思想猜到商品准确的价格。\n问题 3：为什么有一些二分查找取 mid 的时候，括号里要加 1? 这是因为\n1  int mid = (left + right) / 2   在区间里有偶数个元素的时候，mid 只能取到位于左边的中间数，要想取到位于右边的中间数，就需要在括号里加 1。\n为什么要取右边中间数呢？这是因为在区间里 只有 222 个元素的时候，把 [left..right] 划分成 [left..mid - 1] 和 [mid..right] 这两个区间，\n1  int mid = (left + right) / 2   这种取法不能把搜索区间缩小。\n理解这件事情最典型的例子是「力扣」第 69 题，详细的分析和调试在 这里。\n总之就是为了：避免死循环。\n问题 4：能不能解释一下其它「二分查找」的模板为什么是对的？ 这个问题我已经回答在 题目求助｜二分查找不同实现方法细节困惑。我再补充一下：不管是哪一种模板，都不会回答看到的 mid 的值以后如何设计条件，把区间进行正确的划分，以及：\n 在某种条件下，mid 的值是否可以取到； 下一轮搜索是在 mid 的左边还是右边继续查找。  「模板一」告诉你全部把 mid 排除掉，用 ans 做补救，保证不会错过答案，「模板三」告诉你全部把 mid 保留，退出循环以后 [left..right] 里剩下两个数，再单独判断一下。它们有「限制死的地方」，所以一定要再理解清楚题意的情况下，正确使用。这些模板没有好坏和优劣之分，它们背后解决问题的思想是一样的。\n再次强调一下：我们学习算法不是背了一个模板然后往里面填空，而是我们真的清楚写的代码每一步在做什么，每一步搜索的范围是什么。更不是因为把区间表示成「左闭右开」而使得问题变得简单。\n问题 5：什么时候 right 取 len ？什么时候 right = len - 1？ 回答：这种问题就像你问我什么时候向左边找，什么时候向右边找，我的回答都是：看题目，每个问题的答案都未必一样。\n先回答什么时候 right 取 len ？什么时候 right = len - 1？就像本题（「力扣」第 35 题），「示例 3」就告诉我们，len 是有可能成为答案的，所以设置 right = len，上面第一部分「参考代码 2」的写法，「参考代码 1」已经做了一次判断，在 len 不可能是答案的情况下，才设置 right = len - 1。这一点请不要扯上区间「左闭右开」和「左闭右闭」了，毫无关系。\n「力扣」第 34 题，查找 target 在有序数组出现的第一次的位置和最后一次出现的位置，既然是数组里的位置，最小是 0，最大是 len - 1。\n用这两个例子还是想说：到底设置的搜索区间是什么，看题目怎么说。\n再回答什么时候向左边找，什么时候向右边找。回答还是 看题目：输入数组是升序还是降序，决定了向左边找还是向右边找。\n 总结：如果不能够正确理解题意，不去真正仔细的做练习、分析和总结，凭空想到底这些问题改怎么做，抱怨「二分查找」细节多、难是没有用的。其实根本没有想象中的难。用最直接、简单的想法看待「二分查找」就可以。\n 下面再为大家总结一下「二分查找」的重点。\n二分查找重点概括  写成 while(left ，退出循环的时候有 left == right 成立，好处是：不用判断应该返回 left 还是 right； 区间 [left..right] 划分只有以下两种情况：   分成 [left..mid] 和 [mid + 1..right]，分别对应 right = mid 和 left = mid + 1；\n  分成 [left..mid - 1] 和 [mid..right]，分别对应 right = mid - 1 和 left = mid，这种情况下。需要将\n1  int mid = (left + right) / 2   改成\n1  int mid = (left + right + 1) / 2   ，否则会出现死循环，这一点不用记，出现死循环的时候，把 left和right 的值打印出来看一下就很清楚了；\n   退出循环 left == right，如果可以确定区间 [left..right] 一定有解，直接返回 left 就可以，否则还需要对 left 这个位置单独做一次判断； 始终保持不变的是：在区间 [left..right] 里查找目标元素。  关于如何写对二分查找，二分查找的详细讲解，可以查看我编写的 LeetBook 的「二分查找」 章节。\n 第三部分：二分查找题解列表（包含文字题解和视频题解） 以下是练习（我写过很多「二分查找习题列表」，我暂时先把它们汇总在这里）。\n提示：这些问题都不应该套模板去做，而应该在真正弄清楚题意（明确地知道题目要我们找的元素的性质）以后，对看到的元素进行合理的分支判断，进而清楚搜索的范围。\n二分查找的基本思想是「减而治之」，即逐渐缩小问题规模。以下的二分查找问题，我们都不应该背下来，而应该在练习的过程中逐渐掌握分析问题、解决问题的方法。\n可以采用的循环不变量是：总是在区间 [left..right] 里查找目标元素。采用左闭右开区间只会增加麻烦。\n遇到问题的时候，一定需要仔细调试，使用最最基本的打印输出语句，针对错误测试用例，发现出错的原因。\n题型一：二分求下标（在数组中查找符合条件的元素的下标） 说明：\n   第 704 题：二分查找的最原始问题，使用两边夹的二分查找方法需要后处理（退出循环以后，还需要判断 left 或 right 位置的值是不是问题的答案）；\n    第 34 题、第 35 题：需要明白这一类问题的共同特点，请见 这里；\n    第 300 题：特别经典的一道「动态规划」，二分查找的思路基于「动态规划」的状态定义得到，代码很像第 35 题；\n    第 658 题：这个问题二分的写法需要做复杂的分类讨论，可以放在以后做；\n    第 4 题：二分查找里最难的问题，重点在于理解：① 为什么是在短数组里找边界；② 深刻理解搜索边界的意义。\n      题号 链接 题解     704 二分查找（简单）    35 搜索插入位置（简单） 【视频讲解】、文字题解   300 最长上升子序列（中等） 文字题解   34 在排序数组中查找元素的第一个和最后一个位置（简单） 【视频讲解】、文字题解   611 有效三角形的个数 文字题解   658 找到 K 个最接近的元素（中等） 文字题解   436 寻找右区间（中等） 文字题解   1237 找出给定方程的正整数解（中等）    1300 转变数组后最接近目标值的数组和（中等） 文字题解   4 寻找两个有序数组的中位数（困难） 【视频讲解】、文字题解    使用二分查找的前提不一定非要是「有序数组」。旋转有序数组（下表前 4 题）、山脉数组（下表后 2 题）里的查找问题也可以使用「二分查找」。这些问题的解决思路是：利用 局部单调性，逐步缩小搜索区间。\n   题号 链接 题解     33 搜索旋转排序数组（中等） 文字题解   81 搜索旋转排序数组 II（中等） 文字题解   153 寻找旋转排序数组中的最小值（中等） 文字题解   154 寻找旋转排序数组中的最小值 II（困难） 文字题解   852 山脉数组的峰顶索引（简单）    1095 山脉数组中查找目标值（中等） 【视频讲解】、文字题解    题型二：二分答案（在一个有范围的区间里搜索一个整数） 如果题目要我们找一个整数，这个整数有确定的范围，可以通过二分查找逐渐缩小范围，最后逼近到一个数。\n定位一个有范围的整数，这件事情也叫「二分答案」或者叫「二分结果」。如果题目要求的是一个整数，这个整数有明确的范围，可以考虑使用二分查找。\n事实上，二分答案是我们最早接触的二分查找的场景。「幸运 52」里猜价格游戏，就是「二分查找」算法的典型应用：先随便猜一个数，如果猜中，游戏结束。如果猜大了，往小猜；如果猜小了，往大猜。\n说明：\n 第 69 题：在一个整数范围里查找一个整数，也是二分查找法的应用场景； 第 275 题：这个问题题解题意得花很多时间，可以跳过不做； 第 278 题：在一个整数范围里查找一个整数，不是在输入数组里使用二分查找。这个问题二分查找的解法很反常规（不应该用时间换空间），知道即可。     题号 链接 题解     69 x 的平方根（简单） 文字题解   287 寻找重复数（中等） 文字题解   374 猜数字大小（简单） 文字题解   275 H指数 II（中等） 文字题解   1283 使结果不超过阈值的最小除数（中等） 文字题解   1292 元素和小于等于阈值的正方形的最大边长（中等）     题型三：二分答案的升级版（每一次缩小区间的时候都需要遍历数组） 说明：这一类问题本质上还是「题型二」（二分答案），但是初学的时候会觉得有一些绕。这一类问题的问法都差不多，关键字是「连续」、「正整数」，请大家注意捕捉题目中这样的关键信息。\n这里给出的问题解法都一样，会一题等于会其它题。问题的场景会告诉我们：目标变量和另一个变量有相关关系（一般是线性关系），目标变量的性质不好推测，但是另一个变量的性质相对容易推测（满足某种意义上的单调性）。这样的问题的判别函数通常会写成一个函数的形式。\n这一类问题可以统称为「 最大值极小化 」问题，最原始的问题场景是木棍切割问题，这道题的原始问题是「力扣」第 410 题（分割数组的最大值（困难））。\n思路是这样的：\n 分析出题目要我们找一个整数，这个整数有范围，所以可以用二分查找； 分析出 单调性，一般来说是一个变量 a 的值大了，另一个变量 b 的值就变小，而「另一个变量的值」 b 有限制，因此可以通过调整 a 的值达到控制 b 的效果； 这一类问题的题目条件一定会给出 连续、正整数 这样的关键字。如果没有，问题场景也一定蕴含了这两个关键信息。  参考资料：\n 二分查找之「最大值极小化」相关问题及解题步骤 二分查找之「最大值极小化」例题选讲  以下给出的问题无一例外。\n   题号 链接 题解     875 爱吃香蕉的珂珂（中等） 文字题解   410 分割数组的最大值（困难） 文字题解   LCP 12 小张刷题计划（中等） 题解在第 410 题题解里   1011 在 D 天内送达包裹的能力（中等）    1482 制作 m 束花所需的最少天数（中等） 题解在第 1300 题题解里   1552 两球之间的磁力（中等）     补充：「力扣」第 209 题：长度最小的子数组（中等），这道题可以使用「前缀和 + 二分查找」或者「滑动窗口」来做，一定要想清楚，为什么可以使用这些方法。\n","wordCount":"860","inLanguage":"en","datePublished":"2022-03-16T15:58:36+08:00","dateModified":"2022-03-16T15:58:36+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zachmelody.github.io/posts/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},"publisher":{"@type":"Organization","name":"旋律小站","logo":{"@type":"ImageObject","url":"https://zachmelody.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zachmelody.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://zachmelody.github.io/%E5%AD%A6%E5%8E%86.svg alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://zachmelody.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://zachmelody.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://zachmelody.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class="main page"><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zachmelody.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://zachmelody.github.io/posts/>Posts</a></div><h1 class=post-title>二分查找</h1><div class=post-meta><span title="2022-03-16 15:58:36 +0800 +0800">March 16, 2022</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e7%ac%ac%e4%b8%80%e9%83%a8%e5%88%86%e6%9c%ac%e9%a2%98%e9%a2%98%e8%a7%a3 aria-label=第一部分：本题题解>第一部分：本题题解</a><ul><li><a href=#%e9%a2%98%e6%84%8f%e5%88%86%e6%9e%90 aria-label=题意分析>题意分析</a></li><li><a href=#%e6%80%9d%e8%b7%af%e5%88%86%e6%9e%90 aria-label=思路分析>思路分析</a></li></ul></li><li><a href=#%e7%ac%ac%e4%ba%8c%e9%83%a8%e5%88%86%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98%e5%9b%9e%e7%ad%94 aria-label=第二部分：二分查找常见问题回答>第二部分：二分查找常见问题回答</a><ul><li><a href=#%e9%97%ae%e9%a2%98-1%e4%b8%ba%e4%bb%80%e4%b9%88%e5%9c%a8%e4%bd%a0%e7%9a%84%e9%a2%98%e8%a7%a3%e9%87%8c-while-left--right-%e8%a1%a8%e7%a4%ba%e5%b7%a6%e9%97%ad%e5%8f%b3%e9%97%ad%e5%8c%ba%e9%97%b4 aria-label="问题 1：为什么在你的题解里 while (left &amp;lt; right) 表示左闭右闭区间"><code>问题 1</code>：为什么在你的题解里 <code>while (left &lt; right)</code> 表示左闭右闭区间</a></li><li><a href=#%e9%97%ae%e9%a2%98-2%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be%e6%98%af%e4%b8%8d%e6%98%af%e8%a6%81%e6%b1%82%e6%95%b0%e7%bb%84%e4%b8%80%e5%ae%9a%e6%98%af%e6%9c%89%e5%ba%8f%e7%9a%84 aria-label="问题 2：二分查找是不是要求数组一定是有序的？"><code>问题 2</code>：二分查找是不是要求数组一定是有序的？</a></li><li><a href=#%e9%97%ae%e9%a2%98-3%e4%b8%ba%e4%bb%80%e4%b9%88%e6%9c%89%e4%b8%80%e4%ba%9b%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be%e5%8f%96-mid-%e7%9a%84%e6%97%b6%e5%80%99%e6%8b%ac%e5%8f%b7%e9%87%8c%e8%a6%81%e5%8a%a0-1 aria-label="问题 3：为什么有一些二分查找取 mid 的时候，括号里要加 1?"><code>问题 3</code>：为什么有一些二分查找取 <code>mid</code> 的时候，括号里要加 1?</a></li><li><a href=#%e9%97%ae%e9%a2%98-4%e8%83%bd%e4%b8%8d%e8%83%bd%e8%a7%a3%e9%87%8a%e4%b8%80%e4%b8%8b%e5%85%b6%e5%ae%83%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be%e7%9a%84%e6%a8%a1%e6%9d%bf%e4%b8%ba%e4%bb%80%e4%b9%88%e6%98%af%e5%af%b9%e7%9a%84 aria-label="问题 4：能不能解释一下其它「二分查找」的模板为什么是对的？"><code>问题 4</code>：能不能解释一下其它「二分查找」的模板为什么是对的？</a></li><li><a href=#%e9%97%ae%e9%a2%98-5%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99-right-%e5%8f%96-len-%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99-right--len---1 aria-label="问题 5：什么时候 right 取 len ？什么时候 right = len - 1？"><code>问题 5</code>：什么时候 <code>right</code> 取 <code>len</code> ？什么时候 <code>right = len - 1</code>？</a></li><li><a href=#%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be%e9%87%8d%e7%82%b9%e6%a6%82%e6%8b%ac aria-label=二分查找重点概括>二分查找重点概括</a></li></ul></li><li><a href=#%e7%ac%ac%e4%b8%89%e9%83%a8%e5%88%86%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be%e9%a2%98%e8%a7%a3%e5%88%97%e8%a1%a8%e5%8c%85%e5%90%ab%e6%96%87%e5%ad%97%e9%a2%98%e8%a7%a3%e5%92%8c%e8%a7%86%e9%a2%91%e9%a2%98%e8%a7%a3 aria-label=第三部分：二分查找题解列表（包含文字题解和视频题解）>第三部分：二分查找题解列表（包含文字题解和视频题解）</a><ul><li><a href=#%e9%a2%98%e5%9e%8b%e4%b8%80%e4%ba%8c%e5%88%86%e6%b1%82%e4%b8%8b%e6%a0%87%e5%9c%a8%e6%95%b0%e7%bb%84%e4%b8%ad%e6%9f%a5%e6%89%be%e7%ac%a6%e5%90%88%e6%9d%a1%e4%bb%b6%e7%9a%84%e5%85%83%e7%b4%a0%e7%9a%84%e4%b8%8b%e6%a0%87 aria-label=题型一：二分求下标（在数组中查找符合条件的元素的下标）>题型一：二分求下标（在数组中查找符合条件的元素的下标）</a></li><li><a href=#%e9%a2%98%e5%9e%8b%e4%ba%8c%e4%ba%8c%e5%88%86%e7%ad%94%e6%a1%88%e5%9c%a8%e4%b8%80%e4%b8%aa%e6%9c%89%e8%8c%83%e5%9b%b4%e7%9a%84%e5%8c%ba%e9%97%b4%e9%87%8c%e6%90%9c%e7%b4%a2%e4%b8%80%e4%b8%aa%e6%95%b4%e6%95%b0 aria-label=题型二：二分答案（在一个有范围的区间里搜索一个整数）>题型二：二分答案（在一个有范围的区间里搜索一个整数）</a></li><li><a href=#%e9%a2%98%e5%9e%8b%e4%b8%89%e4%ba%8c%e5%88%86%e7%ad%94%e6%a1%88%e7%9a%84%e5%8d%87%e7%ba%a7%e7%89%88%e6%af%8f%e4%b8%80%e6%ac%a1%e7%bc%a9%e5%b0%8f%e5%8c%ba%e9%97%b4%e7%9a%84%e6%97%b6%e5%80%99%e9%83%bd%e9%9c%80%e8%a6%81%e9%81%8d%e5%8e%86%e6%95%b0%e7%bb%84 aria-label=题型三：二分答案的升级版（每一次缩小区间的时候都需要遍历数组）>题型三：二分答案的升级版（每一次缩小区间的时候都需要遍历数组）</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const e=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${e}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><blockquote><p><a href=https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/>https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/</a></p></blockquote><p>阅读提示：内容比较多，核心思想帮大家归纳一下。如果没有时间看，建议把后面的问题做一下。</p><blockquote><p>题解核心内容：所有模板都一样，不可以套模板，而应该 <code>仔细看题（解题的关键在认真读题）</code>，分析清楚题目要找的答案需要满足什么性质。采用两边夹的方式，每一轮把待搜索区间分成两个部分，排除掉一定不是答案的区间，最后左右指针重合的地方就是我们要找的元素。</p></blockquote><p><code>说明</code>：我所有的关于「二分查找」法的题解，都会明确地标注「下一轮搜索区间是什么」，进而设置左边界 <code>left</code> 和 右边界 <code>right</code>。在我写的「二分查找」题解里，<code>while(left &lt; right)</code> <code>不表示</code> 循环不变量的区间定义是 <code>[left..right)</code>，也就是说，如果我分析出，下一轮搜索区间是 <code>[mid..10]</code>，我会设置 <code>right = 10</code>，而不会设置 <code>right = 11</code>。</p><p>如果你看我写的「二分查找」题解，请忘记掉「左闭右开」这件事情，它会对你有所干扰。</p><p>二分查找只有一个思想，那就是：<code>逐步缩小搜索区间</code>。</p><blockquote><p>本题解向大家介绍的，使用 <code>left</code> 和 <code>right</code> 向中间靠拢的方法，有一个非常强的语义，那就是：<code>当 </code>left<code>与</code>right<code> 重合的时候，我们就找到了问题的答案</code>，使用这种写法有一个巨大的好处，那就是返回值不需要考虑返回 <code>left</code> 还是 <code>right</code>，因为退出循环以后，它们是重合的。</p></blockquote><p><img loading=lazy src=https://pic.leetcode-cn.com/1639968622-EzQzeJ-binary-search-%E8%A3%81%E5%89%AA.gif alt=binary-search-裁剪.gif></p><blockquote><p>在做题的过程中，会遇到两个难点：1、取 <code>mid</code> 的时候，有些时候需要 <code>+1</code>，这是因为需要避免死循环；2、只把区间分成两个部分，这是因为：只有这样，退出循环的时候才有 <code>left</code> 与 <code>right</code> 重合，我们才敢说，找到了问题的答案。（这两个难点，在练习的过程中，会逐渐清晰，不用着急一下子搞懂，事实上并不难理解）。</p></blockquote><hr><h2 id=第一部分本题题解>第一部分：本题题解<a hidden class=anchor aria-hidden=true href=#第一部分本题题解>#</a></h2><blockquote><p>这一部分一定要分析清楚：</p></blockquote><ul><li>题目要找的元素是：第一个大于等于 <code>target</code> 的元素的下标；</li><li>数组的长度 <code>len</code> 也有可能是问题的答案，「参考代码 2」设置 <code>right = len</code> 不是因为设置区间是「左闭右开」，而是因为 <code>len</code> 本来就有可能是问题的答案。</li></ul><blockquote><p>上面 2 个小点，都需要仔细分析题意和几个示例得到，任何模板都不能回答这样的问题。</p></blockquote><h3 id=题意分析>题意分析<a hidden class=anchor aria-hidden=true href=#题意分析>#</a></h3><p>根据示例，分析题目要我们返回的「插入元素的位置」是什么。</p><h3 id=思路分析>思路分析<a hidden class=anchor aria-hidden=true href=#思路分析>#</a></h3><p>在有序数组中查找，可以使用「二分查找」。</p><p>根据「题意分析」中对示例的描述：</p><ul><li>情况 1：<code>如果当前 </code>mid<code>看到的数值严格小于</code>target<code>，那么 </code>mid<code>以及</code>mid<code> 左边的所有元素就一定不是「插入元素的位置」</code>，因此下一轮搜索区间是 <code>[mid + 1..right]</code>，下一轮把 <code>left</code> 移动到 <code>mid + 1</code> 位置，因此设置 <code>left = mid + 1</code>；</li><li>情况 2：否则，如果 <code>mid</code> 看到的数值大于等于 <code>target</code>，那么 <code>mid</code> <code>可能是「插入元素的位置」</code>，<code>mid</code> 的右边一定不存在「插入元素的位置」。如果 <code>mid</code> 的左边不存在「插入元素的位置」，我们才可以说 <code>mid</code> 是「插入元素的位置」。因此下一轮搜索区间是 <code>[left..mid]</code>，下一轮把 <code>right</code> 移动到 <code>mid</code> 位置，因此设置 <code>right = mid</code>。</li></ul><p><code>说明</code>：上面的两点中，「情况 2」其实不用分析得那么细致， 因为只要「情况 1」的区间分析是正确的，「情况 2」一定是「情况 1」得到的区间的反面区间。</p><p><code>参考代码 1</code>：</p><ul><li>Java</li></ul><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>public class Solution {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    public int searchInsert(int[] nums, int target) {
</span></span><span style=display:flex><span>        int len = nums.length;
</span></span><span style=display:flex><span>        // 特殊判断
</span></span><span style=display:flex><span>        if (nums[len - 1] &lt; target) {
</span></span><span style=display:flex><span>            return len;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        // 程序走到这里一定有 nums[len - 1] &gt;= target，插入位置在区间 [.len - 1]
</span></span><span style=display:flex><span>        int left = 0;
</span></span><span style=display:flex><span>        int right = len - 1;
</span></span><span style=display:flex><span>        // 在区间 nums[left..right] 里查找第 1 个大于等于 target 的元素的下标
</span></span><span style=display:flex><span>        while (left &lt; right) {
</span></span><span style=display:flex><span>            int mid = left + (right - left) / 2;
</span></span><span style=display:flex><span>            if (nums[mid] &lt; target){
</span></span><span style=display:flex><span>                // 下一轮搜索的区间是 [mid + .right]
</span></span><span style=display:flex><span>                left = mid + 1;
</span></span><span style=display:flex><span>            } else {
</span></span><span style=display:flex><span>                // 下一轮搜索的区间是 [left..mid]
</span></span><span style=display:flex><span>                right = mid;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        return left;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p><code>说明</code>：<code>while (left &lt; right)</code> 表示当 <code>left</code> 与 <code>right</code> 重合的时候，搜索终止。<code>根据题意和示例</code>，区间 <code>nums[left..right]</code> 里一定存在「插入元素的位置」，且 <code>while</code> 循环里只把区间分成两个部分，退出循环的时候一定有 <code>left == right</code> 成立，因此返回 <code>left</code> 或者 <code>right</code> 都可以。</p><p><code>复杂度分析</code>：</p><ul><li>时间复杂度：O(log⁡N)O(\log N)O(logN)，这里 NNN 是输入数组的长度；</li><li>空间复杂度：O(1)O(1)O(1)。</li></ul><p>既然 <code>len</code> 也有可能是答案，可以在初始化的时候，把 <code>right</code> 设置成 <code>len</code>，在一开始的时候就不需要特殊判断了。</p><p><code>参考代码 2</code>：</p><ul><li>Java</li></ul><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>public class Solution {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    public int searchInsert(int[] nums, int target) {
</span></span><span style=display:flex><span>        int len = nums.length;
</span></span><span style=display:flex><span>        int left = 0;
</span></span><span style=display:flex><span>        int right = len;
</span></span><span style=display:flex><span>        // 在区间 nums[left..right] 里查找第 1 个大于等于 target 的元素的下标
</span></span><span style=display:flex><span>        while (left &lt; right) {
</span></span><span style=display:flex><span>            int mid = left + (right - left) / 2;
</span></span><span style=display:flex><span>            if (nums[mid] &lt; target){
</span></span><span style=display:flex><span>                // 下一轮搜索的区间是 [mid + .right]
</span></span><span style=display:flex><span>                left = mid + 1;
</span></span><span style=display:flex><span>            } else {
</span></span><span style=display:flex><span>                // 下一轮搜索的区间是 [left..mid]
</span></span><span style=display:flex><span>                right = mid;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        return left;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p><code>复杂度分析</code>：（同参考代码 1）</p><hr><h2 id=第二部分二分查找常见问题回答>第二部分：二分查找常见问题回答<a hidden class=anchor aria-hidden=true href=#第二部分二分查找常见问题回答>#</a></h2><p><code>温馨提示</code>：</p><ul><li>以下内容有点多，但是都是非常简单直观的内容。我整理了在我的题解下网友的诸多疑问，进行了总结，希望大家能认真看看；</li><li>真的踏踏实实做完一些二分查找的问题，已经有了足够的思考，就会觉得没有那么难。</li></ul><h3 id=问题-1为什么在你的题解里-while-left--right-表示左闭右闭区间><code>问题 1</code>：为什么在你的题解里 <code>while (left &lt; right)</code> 表示左闭右闭区间<a hidden class=anchor aria-hidden=true href=#问题-1为什么在你的题解里-while-left--right-表示左闭右闭区间>#</a></h3><p><code>回答</code>：看到 <code>while (left &lt; right)</code> 不表示搜索区间为「左闭右开」，这一点没有根据。<code>真正应该看边界如何设置</code>，这一点完全是人为定义。</p><p>表示一个区间，最直接的表示就是左闭右闭区间。例如：我们想表示搜索的范围是</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>1, 2, 3, 4, 5, 6, 7, 8, 9
</span></span></code></pre></td></tr></table></div></div><p>，很自然地会表示成 <code>[1..9]</code> ，我们也会说这些数是 <code>1</code> 到 <code>9</code> 之间的数，包括 <code>1</code> 和 <code>9</code>。正常情况下，不会说：这些数在 <code>1</code> 到 <code>10</code> 之间，不包括 <code>10</code>；</p><p>只看到 <code>while (left &lt; right)</code> 里的 <code>&lt;</code> ，不能说明右边界不能取到。真正看区间表示应该看左右边界到底如何设置，如果我们分析出下一轮搜索的范围是 <code>[left..mid]</code> 而设置 <code>right = mid + 1</code>，才表示搜索区间为「左闭右开」区间 。这是因为</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>[left..right) = [left..mid + 1) = [left..mid]
</span></span></code></pre></td></tr></table></div></div><p>可以看到，任何一个「左闭右开」区间都对应一个「左闭右闭」区间。我们已经可以确切地知道要搜索的数的右边界是什么， 没有必要把右边界再 +1+1+1。</p><p><code>重点</code>：真正写对「二分查找」，从来不在于我们把区间写成了「左闭右开」还是「左闭右闭」，而是 <code>在于我们能够根据题意：得到某种单调性，和可以逐步缩小搜索规模的条件，进而准确地设计可以使得搜索区间缩小的条件</code>。</p><h3 id=问题-2二分查找是不是要求数组一定是有序的><code>问题 2</code>：二分查找是不是要求数组一定是有序的？<a hidden class=anchor aria-hidden=true href=#问题-2二分查找是不是要求数组一定是有序的>#</a></h3><p><code>回答</code>：不一定。</p><p>「力扣」上有一些问题输入数组不是有序的，例如「旋转有序数组」「山脉数组」（题号在第三部分的习题列表里），这些问题题目给出的是「接近有序」的数组，依然可以使用「二分查找」，这是因为这些数组都有规律可循，可以根据看到的 <code>num[mid]</code> 的值，推测两侧元素的性质，进而 <code>缩小搜索区间</code>。</p><p>还有一类问题，例如「力扣」第 287 题，<code>这一类题目不是在输入数组上做二分</code>，而是在输入数组的最小值 <code>min</code> 和最大值 <code>max</code> 组成的连续整数数组上查找一个数，即搜索区间是 <code>[min..max]</code>，这个区间是单调的。</p><p>这一类问题的特点是：题目要我们找一个整数，这个整数的范围是确定的，可以使用「二分查找」，这样的问题叫「二分答案」。很多引入「二分查找」的例子，其实就是在做「二分答案」，《幸运 52》猜价格游戏，就是在用「二分查找」的思想猜到商品准确的价格。</p><h3 id=问题-3为什么有一些二分查找取-mid-的时候括号里要加-1><code>问题 3</code>：为什么有一些二分查找取 <code>mid</code> 的时候，括号里要加 1?<a hidden class=anchor aria-hidden=true href=#问题-3为什么有一些二分查找取-mid-的时候括号里要加-1>#</a></h3><p>这是因为</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>int mid = (left + right) / 2
</span></span></code></pre></td></tr></table></div></div><p>在区间里有偶数个元素的时候，<code>mid</code> 只能取到位于左边的中间数，要想取到位于右边的中间数，就需要在括号里加 1。</p><p>为什么要取右边中间数呢？这是因为在区间里 <code>只有 222 个元素的时候</code>，把 <code>[left..right]</code> 划分成 <code>[left..mid - 1]</code> 和 <code>[mid..right]</code> 这两个区间，</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>int mid = (left + right) / 2
</span></span></code></pre></td></tr></table></div></div><p>这种取法不能把搜索区间缩小。</p><p>理解这件事情最典型的例子是「力扣」第 69 题，详细的分析和调试在 这里。</p><p><code>总之就是为了：避免死循环</code>。</p><h3 id=问题-4能不能解释一下其它二分查找的模板为什么是对的><code>问题 4</code>：能不能解释一下其它「二分查找」的模板为什么是对的？<a hidden class=anchor aria-hidden=true href=#问题-4能不能解释一下其它二分查找的模板为什么是对的>#</a></h3><p>这个问题我已经回答在 题目求助｜二分查找不同实现方法细节困惑。我再补充一下：不管是哪一种模板，都不会回答看到的 <code>mid</code> 的值以后如何设计条件，把区间进行正确的划分，以及：</p><ul><li>在某种条件下，<code>mid</code> 的值是否可以取到；</li><li>下一轮搜索是在 <code>mid</code> 的左边还是右边继续查找。</li></ul><p>「模板一」告诉你全部把 <code>mid</code> 排除掉，用 <code>ans</code> 做补救，保证不会错过答案，「模板三」告诉你全部把 <code>mid</code> 保留，退出循环以后 <code>[left..right]</code> 里剩下两个数，再单独判断一下。它们有「限制死的地方」，所以一定要再理解清楚题意的情况下，正确使用。这些模板没有好坏和优劣之分，它们背后解决问题的思想是一样的。</p><p>再次强调一下：我们学习算法不是背了一个模板然后往里面填空，而是我们真的清楚写的代码每一步在做什么，每一步搜索的范围是什么。更不是因为把区间表示成「左闭右开」而使得问题变得简单。</p><h3 id=问题-5什么时候-right-取-len-什么时候-right--len---1><code>问题 5</code>：什么时候 <code>right</code> 取 <code>len</code> ？什么时候 <code>right = len - 1</code>？<a hidden class=anchor aria-hidden=true href=#问题-5什么时候-right-取-len-什么时候-right--len---1>#</a></h3><p><code>回答</code>：这种问题就像你问我什么时候向左边找，什么时候向右边找，我的回答都是：<code>看题目，每个问题的答案都未必一样</code>。</p><p>先回答什么时候 <code>right</code> 取 <code>len</code> ？什么时候 <code>right = len - 1</code>？就像本题（「力扣」第 35 题），「示例 3」就告诉我们，<code>len</code> 是有可能成为答案的，所以设置 <code>right = len</code>，上面第一部分「参考代码 2」的写法，「参考代码 1」已经做了一次判断，在 <code>len</code> 不可能是答案的情况下，才设置 <code>right = len - 1</code>。这一点请不要扯上区间「左闭右开」和「左闭右闭」了，毫无关系。</p><p>「力扣」第 34 题，查找 <code>target</code> 在有序数组出现的第一次的位置和最后一次出现的位置，既然是数组里的位置，最小是 <code>0</code>，最大是 <code>len - 1</code>。</p><p>用这两个例子还是想说：到底设置的搜索区间是什么，看题目怎么说。</p><p>再回答什么时候向左边找，什么时候向右边找。回答还是 <code>看题目</code>：输入数组是升序还是降序，决定了向左边找还是向右边找。</p><blockquote><p><code>总结</code>：如果不能够正确理解题意，不去真正仔细的做练习、分析和总结，凭空想到底这些问题改怎么做，抱怨「二分查找」细节多、难是没有用的。其实根本没有想象中的难。用最直接、简单的想法看待「二分查找」就可以。</p></blockquote><p>下面再为大家总结一下「二分查找」的重点。</p><h3 id=二分查找重点概括>二分查找重点概括<a hidden class=anchor aria-hidden=true href=#二分查找重点概括>#</a></h3><ul><li>写成 <code>while(left &lt; right)</code> ，退出循环的时候有 <code>left == right</code> 成立，好处是：不用判断应该返回 <code>left</code> 还是 <code>right</code>；</li><li>区间 <code>[left..right]</code> 划分只有以下两种情况：<ul><li><p>分成 <code>[left..mid]</code> 和 <code>[mid + 1..right]</code>，分别对应 <code>right = mid</code> 和 <code>left = mid + 1</code>；</p></li><li><p>分成 <code>[left..mid - 1]</code> 和 <code>[mid..right]</code>，分别对应 <code>right = mid - 1</code> 和 <code>left = mid</code>，这种情况下。需要将</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>int mid = (left + right) / 2
</span></span></code></pre></td></tr></table></div></div><p>改成</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>int mid = (left + right + 1) / 2
</span></span></code></pre></td></tr></table></div></div><p>，否则会出现死循环，<code>这一点不用记，出现死循环的时候，把 </code>left<code>和</code>right<code> 的值打印出来看一下就很清楚了</code>；</p></li></ul></li><li>退出循环 <code>left == right</code>，如果可以确定区间 <code>[left..right]</code> 一定有解，直接返回 <code>left</code> 就可以，<code>否则还需要对 </code>left<code> 这个位置单独做一次判断</code>；</li><li>始终保持不变的是：在区间 <code>[left..right]</code> 里查找目标元素。</li></ul><p>关于如何写对二分查找，二分查找的详细讲解，可以查看我编写的 LeetBook 的「二分查找」 章节。</p><hr><h2 id=第三部分二分查找题解列表包含文字题解和视频题解>第三部分：二分查找题解列表（包含文字题解和视频题解）<a hidden class=anchor aria-hidden=true href=#第三部分二分查找题解列表包含文字题解和视频题解>#</a></h2><p>以下是练习（我写过很多「二分查找习题列表」，我暂时先把它们汇总在这里）。</p><p><code>提示</code>：这些问题都不应该套模板去做，而应该在真正弄清楚题意（明确地知道题目要我们找的元素的性质）以后，对看到的元素进行合理的分支判断，进而清楚搜索的范围。</p><p>二分查找的基本思想是「减而治之」，即逐渐缩小问题规模。以下的二分查找问题，我们都不应该背下来，而应该在练习的过程中逐渐掌握分析问题、解决问题的方法。</p><p>可以采用的循环不变量是：总是在区间 <code>[left..right]</code> 里查找目标元素。采用左闭右开区间只会增加麻烦。</p><p>遇到问题的时候，一定需要仔细调试，使用最最基本的打印输出语句，针对错误测试用例，发现出错的原因。</p><h3 id=题型一二分求下标在数组中查找符合条件的元素的下标>题型一：二分求下标（在数组中查找符合条件的元素的下标）<a hidden class=anchor aria-hidden=true href=#题型一二分求下标在数组中查找符合条件的元素的下标>#</a></h3><p><code>说明</code>：</p><ul><li><blockquote><p>第 704 题：二分查找的最原始问题，使用两边夹的二分查找方法需要后处理（退出循环以后，还需要判断 <code>left</code> 或 <code>right</code> 位置的值是不是问题的答案）；</p></blockquote></li><li><blockquote><p>第 34 题、第 35 题：需要明白这一类问题的共同特点，请见 这里；</p></blockquote></li><li><blockquote><p>第 300 题：特别经典的一道「动态规划」，二分查找的思路基于「动态规划」的状态定义得到，代码很像第 35 题；</p></blockquote></li><li><blockquote><p>第 658 题：这个问题二分的写法需要做复杂的分类讨论，可以放在以后做；</p></blockquote></li><li><blockquote><p>第 4 题：二分查找里最难的问题，重点在于理解：① 为什么是在短数组里找边界；② 深刻理解搜索边界的意义。</p></blockquote></li></ul><table><thead><tr><th>题号</th><th>链接</th><th>题解</th></tr></thead><tbody><tr><td>704</td><td>二分查找（简单）</td><td></td></tr><tr><td>35</td><td>搜索插入位置（简单）</td><td>【视频讲解】、文字题解</td></tr><tr><td>300</td><td>最长上升子序列（中等）</td><td>文字题解</td></tr><tr><td>34</td><td>在排序数组中查找元素的第一个和最后一个位置（简单）</td><td>【视频讲解】、文字题解</td></tr><tr><td>611</td><td>有效三角形的个数</td><td>文字题解</td></tr><tr><td>658</td><td>找到 K 个最接近的元素（中等）</td><td>文字题解</td></tr><tr><td>436</td><td>寻找右区间（中等）</td><td>文字题解</td></tr><tr><td>1237</td><td>找出给定方程的正整数解（中等）</td><td></td></tr><tr><td>1300</td><td>转变数组后最接近目标值的数组和（中等）</td><td>文字题解</td></tr><tr><td>4</td><td>寻找两个有序数组的中位数（困难）</td><td>【视频讲解】、文字题解</td></tr></tbody></table><p>使用二分查找的前提不一定非要是「有序数组」。旋转有序数组（下表前 4 题）、山脉数组（下表后 2 题）里的查找问题也可以使用「二分查找」。这些问题的解决思路是：利用 <code>局部单调性</code>，逐步缩小搜索区间。</p><table><thead><tr><th>题号</th><th>链接</th><th>题解</th></tr></thead><tbody><tr><td>33</td><td>搜索旋转排序数组（中等）</td><td>文字题解</td></tr><tr><td>81</td><td>搜索旋转排序数组 II（中等）</td><td>文字题解</td></tr><tr><td>153</td><td>寻找旋转排序数组中的最小值（中等）</td><td>文字题解</td></tr><tr><td>154</td><td>寻找旋转排序数组中的最小值 II（困难）</td><td>文字题解</td></tr><tr><td>852</td><td>山脉数组的峰顶索引（简单）</td><td></td></tr><tr><td>1095</td><td>山脉数组中查找目标值（中等）</td><td>【视频讲解】、文字题解</td></tr></tbody></table><h3 id=题型二二分答案在一个有范围的区间里搜索一个整数>题型二：二分答案（在一个有范围的区间里搜索一个整数）<a hidden class=anchor aria-hidden=true href=#题型二二分答案在一个有范围的区间里搜索一个整数>#</a></h3><p>如果题目要我们找一个整数，这个整数有确定的范围，可以通过二分查找逐渐缩小范围，最后逼近到一个数。</p><p>定位一个有范围的整数，这件事情也叫「二分答案」或者叫「二分结果」。如果题目要求的是一个整数，这个整数有明确的范围，可以考虑使用二分查找。</p><p>事实上，二分答案是我们最早接触的二分查找的场景。「幸运 52」里猜价格游戏，就是「二分查找」算法的典型应用：先随便猜一个数，如果猜中，游戏结束。如果猜大了，往小猜；如果猜小了，往大猜。</p><p><code>说明</code>：</p><ul><li>第 69 题：在一个整数范围里查找一个整数，也是二分查找法的应用场景；</li><li>第 275 题：这个问题题解题意得花很多时间，可以跳过不做；</li><li>第 278 题：在一个整数范围里查找一个整数，<code>不是在输入数组里使用二分查找</code>。这个问题二分查找的解法很反常规（不应该用时间换空间），知道即可。</li></ul><table><thead><tr><th>题号</th><th>链接</th><th>题解</th></tr></thead><tbody><tr><td>69</td><td>x 的平方根（简单）</td><td>文字题解</td></tr><tr><td>287</td><td>寻找重复数（中等）</td><td>文字题解</td></tr><tr><td>374</td><td>猜数字大小（简单）</td><td>文字题解</td></tr><tr><td>275</td><td>H指数 II（中等）</td><td>文字题解</td></tr><tr><td>1283</td><td>使结果不超过阈值的最小除数（中等）</td><td>文字题解</td></tr><tr><td>1292</td><td>元素和小于等于阈值的正方形的最大边长（中等）</td><td></td></tr></tbody></table><h3 id=题型三二分答案的升级版每一次缩小区间的时候都需要遍历数组>题型三：二分答案的升级版（每一次缩小区间的时候都需要遍历数组）<a hidden class=anchor aria-hidden=true href=#题型三二分答案的升级版每一次缩小区间的时候都需要遍历数组>#</a></h3><p><code>说明</code>：这一类问题本质上还是「题型二」（二分答案），但是初学的时候会觉得有一些绕。这一类问题的问法都差不多，<code>关键字是「连续」、「正整数」</code>，请大家注意捕捉题目中这样的关键信息。</p><p>这里给出的问题解法都一样，会一题等于会其它题。问题的场景会告诉我们：<code>目标变量和另一个变量有相关关系（一般是线性关系），目标变量的性质不好推测，但是另一个变量的性质相对容易推测（满足某种意义上的单调性）</code>。这样的问题的判别函数通常会写成一个函数的形式。</p><p>这一类问题可以统称为「 <code>最大值极小化</code> 」问题，最原始的问题场景是木棍切割问题，这道题的原始问题是「力扣」第 410 题（分割数组的最大值（困难））。</p><p>思路是这样的：</p><ul><li>分析出题目要我们找一个整数，这个整数有范围，所以可以用二分查找；</li><li>分析出 <code>单调性</code>，一般来说是一个变量 <code>a</code> 的值大了，另一个变量 <code>b</code> 的值就变小，而「另一个变量的值」 <code>b</code> 有限制，因此可以通过调整 <code>a</code> 的值达到控制 <code>b</code> 的效果；</li><li>这一类问题的题目条件一定会给出 <code>连续</code>、<code>正整数</code> 这样的关键字。如果没有，问题场景也一定蕴含了这两个关键信息。</li></ul><p>参考资料：</p><ul><li>二分查找之「最大值极小化」相关问题及解题步骤</li><li>二分查找之「最大值极小化」例题选讲</li></ul><p>以下给出的问题无一例外。</p><table><thead><tr><th>题号</th><th>链接</th><th>题解</th></tr></thead><tbody><tr><td>875</td><td>爱吃香蕉的珂珂（中等）</td><td>文字题解</td></tr><tr><td>410</td><td>分割数组的最大值（困难）</td><td>文字题解</td></tr><tr><td>LCP 12</td><td>小张刷题计划（中等）</td><td>题解在第 410 题题解里</td></tr><tr><td>1011</td><td>在 D 天内送达包裹的能力（中等）</td><td></td></tr><tr><td>1482</td><td>制作 m 束花所需的最少天数（中等）</td><td>题解在第 1300 题题解里</td></tr><tr><td>1552</td><td>两球之间的磁力（中等）</td><td></td></tr></tbody></table><p>补充：「力扣」第 209 题：长度最小的子数组（中等），这道题可以使用「前缀和 + 二分查找」或者「滑动窗口」来做，一定要想清楚，为什么可以使用这些方法。</p></div><footer class=post-footer><nav class=paginav><a class=prev href=https://zachmelody.github.io/posts/spring/ioc/><span class=title>« Prev Page</span><br><span>IOC</span></a>
<a class=next href=https://zachmelody.github.io/posts/leetcode/%E6%95%B0%E7%BB%84/><span class=title>Next Page »</span><br><span>数组</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 二分查找 on twitter" href="https://twitter.com/intent/tweet/?text=%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be&url=https%3a%2f%2fzachmelody.github.io%2fposts%2fleetcode%2f%25E4%25BA%258C%25E5%2588%2586%25E6%259F%25A5%25E6%2589%25BE%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 二分查找 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fzachmelody.github.io%2fposts%2fleetcode%2f%25E4%25BA%258C%25E5%2588%2586%25E6%259F%25A5%25E6%2589%25BE%2f&title=%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be&summary=%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be&source=https%3a%2f%2fzachmelody.github.io%2fposts%2fleetcode%2f%25E4%25BA%258C%25E5%2588%2586%25E6%259F%25A5%25E6%2589%25BE%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 二分查找 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fzachmelody.github.io%2fposts%2fleetcode%2f%25E4%25BA%258C%25E5%2588%2586%25E6%259F%25A5%25E6%2589%25BE%2f&title=%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 二分查找 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fzachmelody.github.io%2fposts%2fleetcode%2f%25E4%25BA%258C%25E5%2588%2586%25E6%259F%25A5%25E6%2589%25BE%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 二分查找 on whatsapp" href="https://api.whatsapp.com/send?text=%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be%20-%20https%3a%2f%2fzachmelody.github.io%2fposts%2fleetcode%2f%25E4%25BA%258C%25E5%2588%2586%25E6%259F%25A5%25E6%2589%25BE%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 二分查找 on telegram" href="https://telegram.me/share/url?text=%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be&url=https%3a%2f%2fzachmelody.github.io%2fposts%2fleetcode%2f%25E4%25BA%258C%25E5%2588%2586%25E6%259F%25A5%25E6%2589%25BE%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://zachmelody.github.io/>旋律小站</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>