<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>旋律小站</title>
    <link>https://zachmelody.github.io/</link>
    <description>Recent content on 旋律小站</description>
    <image>
      <url>https://zachmelody.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://zachmelody.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 01 Apr 2022 10:40:55 +0800</lastBuildDate><atom:link href="https://zachmelody.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>IOC</title>
      <link>https://zachmelody.github.io/posts/spring/ioc/</link>
      <pubDate>Fri, 01 Apr 2022 10:40:55 +0800</pubDate>
      
      <guid>https://zachmelody.github.io/posts/spring/ioc/</guid>
      <description>Bean 生命周期 https://www.pdai.tech/md/spring/spring-x-framework-ioc-source-3.html#spring-bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B
MVC流程  前端控制器 DispatcherServlet：接收请求、响应结果，相当于转发器，有了DispatcherServlet 就减少了其它组件之间的耦合度。 处理器映射器 HandlerMapping：根据请求的URL来查找Handler 处理器适配器 HandlerAdapter：负责执行Handler 处理器 Handler：处理器，需要程序员开发 视图解析器 ViewResolver：进行视图的解析，根据视图逻辑名将ModelAndView解析成真正的视图（view） 视图View：View是一个接口， 它的实现类支持不同的视图类型，如jsp，freemarker，pdf等等
 （1）用户发送请求至前端控制器DispatcherServlet； （2）DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handler； （3）处理器映射器根据请求url找到具体的处理器Handler，生成处理器对象及处理器拦截器(如果有则生成)，一并返回给DispatcherServlet； （4）DispatcherServlet 调用 HandlerAdapter处理器适配器，请求执行Handler； （5）HandlerAdapter 经过适配调用 具体处理器进行处理业务逻辑； （6）Handler执行完成返回ModelAndView； （7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet； （8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析； （9）ViewResolver解析后返回具体View； （10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中） （11）DispatcherServlet响应用户。
https://www.jianshu.com/p/73d6f1a03005
向上转型 父子对象之间的转换分为了向上转型和向下转型,它们区别如下:
 向上转型 : 通过子类对象(小范围)实例化父类对象(大范围),这种属于自动转换 向下转型 : 通过父类对象(大范围)实例化子类对象(小范围),这种属于强制转换  </description>
    </item>
    
    <item>
      <title>二分查找</title>
      <link>https://zachmelody.github.io/posts/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Wed, 16 Mar 2022 15:58:36 +0800</pubDate>
      
      <guid>https://zachmelody.github.io/posts/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid>
      <description>https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/
 阅读提示：内容比较多，核心思想帮大家归纳一下。如果没有时间看，建议把后面的问题做一下。
 题解核心内容：所有模板都一样，不可以套模板，而应该 仔细看题（解题的关键在认真读题），分析清楚题目要找的答案需要满足什么性质。采用两边夹的方式，每一轮把待搜索区间分成两个部分，排除掉一定不是答案的区间，最后左右指针重合的地方就是我们要找的元素。
 说明：我所有的关于「二分查找」法的题解，都会明确地标注「下一轮搜索区间是什么」，进而设置左边界 left 和 右边界 right。在我写的「二分查找」题解里，while(left &amp;lt; right) 不表示 循环不变量的区间定义是 [left..right)，也就是说，如果我分析出，下一轮搜索区间是 [mid..10]，我会设置 right = 10，而不会设置 right = 11。
如果你看我写的「二分查找」题解，请忘记掉「左闭右开」这件事情，它会对你有所干扰。
二分查找只有一个思想，那就是：逐步缩小搜索区间。
 本题解向大家介绍的，使用 left 和 right 向中间靠拢的方法，有一个非常强的语义，那就是：当 left与right 重合的时候，我们就找到了问题的答案，使用这种写法有一个巨大的好处，那就是返回值不需要考虑返回 left 还是 right，因为退出循环以后，它们是重合的。
  在做题的过程中，会遇到两个难点：1、取 mid 的时候，有些时候需要 +1，这是因为需要避免死循环；2、只把区间分成两个部分，这是因为：只有这样，退出循环的时候才有 left 与 right 重合，我们才敢说，找到了问题的答案。（这两个难点，在练习的过程中，会逐渐清晰，不用着急一下子搞懂，事实上并不难理解）。
  第一部分：本题题解  这一部分一定要分析清楚：
  题目要找的元素是：第一个大于等于 target 的元素的下标； 数组的长度 len 也有可能是问题的答案，「参考代码 2」设置 right = len 不是因为设置区间是「左闭右开」，而是因为 len 本来就有可能是问题的答案。   上面 2 个小点，都需要仔细分析题意和几个示例得到，任何模板都不能回答这样的问题。</description>
    </item>
    
    <item>
      <title>二分查找</title>
      <link>https://zachmelody.github.io/posts/leetcode/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</link>
      <pubDate>Wed, 16 Mar 2022 15:58:36 +0800</pubDate>
      
      <guid>https://zachmelody.github.io/posts/leetcode/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</guid>
      <description>https://blog.csdn.net/Yaokai_AssultMaster/article/details/79492190</description>
    </item>
    
    <item>
      <title>数组</title>
      <link>https://zachmelody.github.io/posts/leetcode/%E6%95%B0%E7%BB%84/</link>
      <pubDate>Tue, 15 Mar 2022 20:16:43 +0800</pubDate>
      
      <guid>https://zachmelody.github.io/posts/leetcode/%E6%95%B0%E7%BB%84/</guid>
      <description>https://leetcode-cn.com/circle/discuss/6Ghjnw/
本篇主要列举一些输入是一维数组或者二维数组的题目，其中包括了一些可以用二分法和摩尔投票法的题目。
 考虑边界？   二分 - 查找元素或者索引    开闭 -&amp;gt; 搜索区间
  计算 mid 时需要防止溢出
  运算优先级
  ！！！部分解释错误 慎看 二分查找细节 https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-xiang-jie-by-labuladong/
  while(left &amp;lt; right) 不表示 循环不变量的区间定义是 [left..right)，也就是说，如果我分析出，下一轮搜索区间是 [mid..10]，我会设置 right = 10，而不会设置 right = 11。
作者：liweiwei1419 链接：https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/
     二分查找：给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值target，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。    剑指 Offer 53 - I. 在排序数组中查找数字 I:统计一个数字在排序数组中出现的次数。</description>
    </item>
    
    <item>
      <title>Java</title>
      <link>https://zachmelody.github.io/posts/face/java/</link>
      <pubDate>Tue, 15 Mar 2022 14:16:49 +0800</pubDate>
      
      <guid>https://zachmelody.github.io/posts/face/java/</guid>
      <description>京东 1、调用反射的有几种方法？ 1 2 3 4  TargetObject.class; Class.forName(&amp;#34;cn.javaguide.TargetObject&amp;#34;); instance.getClass() ClassLoader.loadClass(&amp;#34;cn.javaguide.TargetObject&amp;#34;);   2、线程池的参数、线程池的执行流程、拒绝策略等 1 2 3 4 5 6 7 8  //通过ThreadPoolExecutor构造函数自定义参数创建 ThreadPoolExecutor executor = new ThreadPoolExecutor(  CORE_POOL_SIZE,  MAX_POOL_SIZE,  KEEP_ALIVE_TIME,  TimeUnit.SECONDS,  new ArrayBlockingQueue&amp;lt;&amp;gt;(QUEUE_CAPACITY),  new ThreadPoolExecutor.CallerRunsPolicy());   拒绝策略  ThreadPoolExecutor.AbortPolicy： 抛出 RejectedExecutionException来拒绝新任务的处理。 ThreadPoolExecutor.CallerRunsPolicy： 调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。 ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。 ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。  3、抽象类与接口的区别？ 共同点 ：
 都不能被实例化。 都可以包含抽象方法。 都可以有默认实现的方法（Java 8 可以用 default 关键在接口中定义默认方法）。     参数 抽象类 接口     成员变量 默认 default。可以变量，也可以常量 只可以常量   成员方法 可以抽象，也可以非抽象。抽象类中可以没有抽象方法，但有抽象方法的一定是抽象类 只可以抽象   方法实现 可以有默认的方法实现 接口完全是抽象的（Java 8 可以用 default）   构造器 抽象类可以有构造器 接口不能有构造器   与正常Java类的区别 除了你不能实例化抽象类之外，它和普通Java类没有任何区别 接口是完全不同的类型   访问修饰符 抽象方法可以有public、protected和default这些修饰符 接口方法默认修饰符是public。default。   main方法 抽象方法可以有main方法并且我们可以运行它 接口没有main方法，因此我们不能运行它。   多继承 抽象方法可以继承一个类和实现多个接口 接口只可以继承一个或多个其它接口   添加新方法 如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。 如果你往接口中添加方法，那么你必须改变实现该接口的类。   设计理念 被继承体现的是：”is a”的关系。抽象类中定义的是该继承体系的共性功能 被实现体现的是：”like a”的关系。接口中定义的是该继承体系的扩展功能。    4、重载与重写的区别 重载Overload</description>
    </item>
    
    <item>
      <title>计算机基础</title>
      <link>https://zachmelody.github.io/posts/face/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 14 Mar 2022 15:47:57 +0800</pubDate>
      
      <guid>https://zachmelody.github.io/posts/face/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</guid>
      <description>京东 1、进程与线程的区别？  一个进程至少拥有一个线程，进程可以根据需要创建其他进程，也可以创建若干个线程。而线程虽然可以创建其他线程，但是不能创建进程。 进程是个拥有资源的独立单位，而线程本身基本不拥有资源（只含有必不可少的资源，比如TCB和栈）。 在通信方面进程中所有的线程共享该进程的所有资源在通信方面进程中所有的线程共享该进程的所有资源，并驻留在同一地址空间，访问相同的数据。但是进程只能通过同步，互斥来实现对共享资源的访问 从调度的角度，在引入线程的操作系统中，线程是调度和分派的基本单位，进程是资源分配的基本单位。在同一个进程中，线程的切换不会引起进程的切换，只有在进程中一个线程切换到另一个进程的线程中的时候，才会引起进程的切换。 从系统开销来说。在创建和撤销进程的时候，操作系统所付出的时间和空间开销将远远大于重建或者撤销线程的开销  2、HTTP和HTTPS的区别？   HTTPS 协议（Hyper Text Transfer Protocol Secure），HTTPS 是基于 HTTP 的，用 TCP 作为底层协议，并使用 SSL/TLS 协议用作加密和安全认证。
  SSL/TLS 的核心要素是非对称加密。非对称加密采用两个密钥——一个公钥，一个私钥。在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知。可以设想一个场景，
     数字签名，是 CA 在给服务器颁发证书时，使用散列+加密的组合技术，在证书上盖个章，以此来提供验伪的功能。
     3、了解TCP吗？谈谈三次握手的流程？  https://blog.csdn.net/qzcsu/article/details/72861891
测试双方 收发功能是否可用
  TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态； TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。 TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。 TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。 当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。  4、了解操作系统吗？进程调度的方式？  先到先服务(FCFS)调度算法 : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。 短作业优先(SJF)的调度算法 : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。 时间片轮转调度算法 : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。 多级反馈队列调度算法 ：前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前被公认的一种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。  对于同一个队列中的各个进程，按照FCFS分配时间片调度。比如Q1队列的时间片为N，那么Q1中的作业在经历了N个时间片后若还没有完成，则进入Q2队列等待，若Q2的时间片用完后作业还不能完成，一直进入下一级队列末尾，直至完成。   优先级调度 ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。  5、了解哪些IO模型？  UNIX 系统下， IO 模型一共有 5 种： 同步阻塞 I/O、同步非阻塞 I/O、I/O 多路复用、信号驱动 I/O 和异步 I/O。</description>
    </item>
    
    <item>
      <title>Mysql面试题</title>
      <link>https://zachmelody.github.io/posts/face/mysql/</link>
      <pubDate>Sun, 13 Mar 2022 11:44:44 +0800</pubDate>
      
      <guid>https://zachmelody.github.io/posts/face/mysql/</guid>
      <description>京东 1. 数据库的事务  事务是逻辑上的一组操作，要么都执行，要么都不执行。
 何为 ACID 特性呢？  原子性（Atomicity） 一致性（Consistency） 隔离性（Isolation） 持久性（Durability）  InnoDB 引擎使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性,通过 锁机制、MVCC 等手段来保证事务的隔离性（ 默认支持的隔离级别是 REPEATABLE-READ ）。
2. 建索引的注意事项   选择合适的字段创建索引：
 不为 NULL 的字段 ：对于数据为 NULL 的字段，数据库较难优化 被频繁查询的字段 被作为条件查询的字段 频繁需要排序的字段 被经常频繁用于连接的字段    被频繁更新的字段应该慎重建立索引。
  尽可能的考虑建立联合索引而不是单列索引: 磁盘空间
  注意避免冗余索引 。
  考虑在字符串类型的字段上使用前缀索引代替普通索引。
  3. MySQL中的隔离级别  READ-UNCOMMITTED (读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更 READ-COMMITTED (读取已提交)： 允许读取并发事务已经提交的数据 REPEATABLE-READ (可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改 SERIALIZABLE (可串行化)： 完全服从 ACID，所有的事务依次逐个执行     隔离级别 脏读 不可重复读 幻读     READ-UNCOMMITTED √ √ √   READ-COMMITTED × √ √   REPEATABLE-READ × × √   SERIALIZABLE × × ×    不可重复读和幻读区别：</description>
    </item>
    
    <item>
      <title>转载：Github Pages 部署</title>
      <link>https://zachmelody.github.io/posts/githubpages&#43;action%E9%83%A8%E7%BD%B2hugo/</link>
      <pubDate>Tue, 08 Mar 2022 18:24:04 +0800</pubDate>
      
      <guid>https://zachmelody.github.io/posts/githubpages&#43;action%E9%83%A8%E7%BD%B2hugo/</guid>
      <description>转载自 https://www.waynerv.com/posts/setup-blog-with-hugo-and-github-pages/
 作为一个已经入行了一年多的（老）技术人，维护一个看得过去的个人博客是很有必要的。
刚学编程的时候，还开源过一个基于 Flask 和 MongoDB 的博客项目，但后面就没怎么使用和维护了，除开主观上的懒，还因为：
 自建博客绕不开主机和域名，这是一笔持续的经济成本。国内的主机往往是第一年割肉第二年宰猪，国外的主机访问延迟很高。 国内主机更麻烦的是还需要定期备案，第一个博客就是因为备案到期中断了。 博客功能的实现技术难度不大，开始还有一些新鲜感，有了工作经验后就很难有兴趣继续维护了。  刚好最近有写一些文章的打算，决定找个简单、省事（最后发现并没有）且不花钱的路子把博客再搞起来，一番研究后，选择了生成静态站点发布到 GitHub Pages 的方案。
工作流 整个方案的流程大致如下：
 用 Markdown 格式写作文章。 使用生成器将 markdown 文件转换成静态站点。 将生成的站点内容推送到 GitHub 并发布。  写 markdown 没啥好说的，什么编辑器都可以，我一直用的是 Typora。
静态站点生成器我选择了 Hugo，原因是最近刚好在学 Go，此外还有 Gatsby、Jekyll、Hexo 等很多选项。
接下来要做的工作是生成静态站点并通过 GitHub Pages 发布。
生成静态站点 使用 Hugo 生成静态博客站点非常简单，具体的步骤和用法可以参考官方文档的 Quick Start。下面简单介绍下整个过程：
  安装 Hugo。macOS 下可以直接使用 homebrew 安装：brew install hugo。
  创建一个新的站点。这会生成一个特定目录结构的项目文件夹，用来维护所有的站点内容。假设我们想把它命名为 hugo-blog，则使用以下命令创建并切换到该目录，后续的操作和命令都会在这个根目录下执行：
  1 2   hugo new site hugo-blog  cd hugo-blog    安装一个主题。这一步是必需的，否则会因为缺少基础模板无法生成站点。安装主题有 3 种方式，以 eureka 主题为例：</description>
    </item>
    
    
  </channel>
</rss>
