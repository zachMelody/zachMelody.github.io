<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java | 旋律小站</title><meta name=keywords content><meta name=description content="京东 1、调用反射的有几种方法？ 1 2 3 4  TargetObject.class; Class.forName(&#34;cn.javaguide.TargetObject&#34;); instance.getClass() ClassLoader.loadClass(&#34;cn.javaguide.TargetObject&#34;);   2、线程池的参数、线程池的执行流程、拒绝策略等 1 2 3 4 5 6 7 8  //通过ThreadPoolExecutor构造函数自定义参数创建 ThreadPoolExecutor executor = new ThreadPoolExecutor(  CORE_POOL_SIZE,  MAX_POOL_SIZE,  KEEP_ALIVE_TIME,  TimeUnit.SECONDS,  new ArrayBlockingQueue<>(QUEUE_CAPACITY),  new ThreadPoolExecutor.CallerRunsPolicy());   拒绝策略  ThreadPoolExecutor.AbortPolicy： 抛出 RejectedExecutionException来拒绝新任务的处理。 ThreadPoolExecutor.CallerRunsPolicy： 调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。 ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。 ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。  3、抽象类与接口的区别？ 共同点 ：
 都不能被实例化。 都可以包含抽象方法。 都可以有默认实现的方法（Java 8 可以用 default 关键在接口中定义默认方法）。  区别 ："><meta name=author content="Me"><link rel=canonical href=https://zachmelody.github.io/posts/face/java/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=preload href=/%e5%ad%a6%e5%8e%86.svg as=image><link rel=icon href=https://zachmelody.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://zachmelody.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://zachmelody.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://zachmelody.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://zachmelody.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.94.2"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Java"><meta property="og:description" content="京东 1、调用反射的有几种方法？ 1 2 3 4  TargetObject.class; Class.forName(&#34;cn.javaguide.TargetObject&#34;); instance.getClass() ClassLoader.loadClass(&#34;cn.javaguide.TargetObject&#34;);   2、线程池的参数、线程池的执行流程、拒绝策略等 1 2 3 4 5 6 7 8  //通过ThreadPoolExecutor构造函数自定义参数创建 ThreadPoolExecutor executor = new ThreadPoolExecutor(  CORE_POOL_SIZE,  MAX_POOL_SIZE,  KEEP_ALIVE_TIME,  TimeUnit.SECONDS,  new ArrayBlockingQueue<>(QUEUE_CAPACITY),  new ThreadPoolExecutor.CallerRunsPolicy());   拒绝策略  ThreadPoolExecutor.AbortPolicy： 抛出 RejectedExecutionException来拒绝新任务的处理。 ThreadPoolExecutor.CallerRunsPolicy： 调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。 ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。 ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。  3、抽象类与接口的区别？ 共同点 ：
 都不能被实例化。 都可以包含抽象方法。 都可以有默认实现的方法（Java 8 可以用 default 关键在接口中定义默认方法）。  区别 ："><meta property="og:type" content="article"><meta property="og:url" content="https://zachmelody.github.io/posts/face/java/"><meta property="og:image" content="https://zachmelody.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-15T14:16:49+08:00"><meta property="article:modified_time" content="2022-03-15T14:16:49+08:00"><meta property="og:site_name" content="旋律小站"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zachmelody.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Java"><meta name=twitter:description content="京东 1、调用反射的有几种方法？ 1 2 3 4  TargetObject.class; Class.forName(&#34;cn.javaguide.TargetObject&#34;); instance.getClass() ClassLoader.loadClass(&#34;cn.javaguide.TargetObject&#34;);   2、线程池的参数、线程池的执行流程、拒绝策略等 1 2 3 4 5 6 7 8  //通过ThreadPoolExecutor构造函数自定义参数创建 ThreadPoolExecutor executor = new ThreadPoolExecutor(  CORE_POOL_SIZE,  MAX_POOL_SIZE,  KEEP_ALIVE_TIME,  TimeUnit.SECONDS,  new ArrayBlockingQueue<>(QUEUE_CAPACITY),  new ThreadPoolExecutor.CallerRunsPolicy());   拒绝策略  ThreadPoolExecutor.AbortPolicy： 抛出 RejectedExecutionException来拒绝新任务的处理。 ThreadPoolExecutor.CallerRunsPolicy： 调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。 ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。 ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。  3、抽象类与接口的区别？ 共同点 ：
 都不能被实例化。 都可以包含抽象方法。 都可以有默认实现的方法（Java 8 可以用 default 关键在接口中定义默认方法）。  区别 ："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zachmelody.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Java","item":"https://zachmelody.github.io/posts/face/java/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java","name":"Java","description":"京东 1、调用反射的有几种方法？ 1 2 3 4  TargetObject.class; Class.forName(\u0026#34;cn.javaguide.TargetObject\u0026#34;); instance.getClass() ClassLoader.loadClass(\u0026#34;cn.javaguide.TargetObject\u0026#34;);   2、线程池的参数、线程池的执行流程、拒绝策略等 1 2 3 4 5 6 7 8  //通过ThreadPoolExecutor构造函数自定义参数创建 ThreadPoolExecutor executor = new ThreadPoolExecutor(  CORE_POOL_SIZE,  MAX_POOL_SIZE,  KEEP_ALIVE_TIME,  TimeUnit.SECONDS,  new ArrayBlockingQueue\u0026lt;\u0026gt;(QUEUE_CAPACITY),  new ThreadPoolExecutor.CallerRunsPolicy());   拒绝策略  ThreadPoolExecutor.AbortPolicy： 抛出 RejectedExecutionException来拒绝新任务的处理。 ThreadPoolExecutor.CallerRunsPolicy： 调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。 ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。 ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。  3、抽象类与接口的区别？ 共同点 ：\n 都不能被实例化。 都可以包含抽象方法。 都可以有默认实现的方法（Java 8 可以用 default 关键在接口中定义默认方法）。  区别 ：","keywords":[],"articleBody":"京东 1、调用反射的有几种方法？ 1 2 3 4  TargetObject.class; Class.forName(\"cn.javaguide.TargetObject\"); instance.getClass() ClassLoader.loadClass(\"cn.javaguide.TargetObject\");   2、线程池的参数、线程池的执行流程、拒绝策略等 1 2 3 4 5 6 7 8  //通过ThreadPoolExecutor构造函数自定义参数创建 ThreadPoolExecutor executor = new ThreadPoolExecutor(  CORE_POOL_SIZE,  MAX_POOL_SIZE,  KEEP_ALIVE_TIME,  TimeUnit.SECONDS,  new ArrayBlockingQueue(QUEUE_CAPACITY),  new ThreadPoolExecutor.CallerRunsPolicy());   拒绝策略  ThreadPoolExecutor.AbortPolicy： 抛出 RejectedExecutionException来拒绝新任务的处理。 ThreadPoolExecutor.CallerRunsPolicy： 调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。 ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。 ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。  3、抽象类与接口的区别？ 共同点 ：\n 都不能被实例化。 都可以包含抽象方法。 都可以有默认实现的方法（Java 8 可以用 default 关键在接口中定义默认方法）。  区别 ：\n 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系（比如说我们抽象了一个发送短信的抽象类，）。 一个类只能继承一个类，但是可以实现多个接口。 接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。  4、重载与重写的区别 重载Overload\n 重载的方法必须具有不同的参数列表。  重写Override\n 参数返回值相同 构造方法不能被重写 父类方法抛出异常，子类也要抛出异常，且不能多于父类抛出的异常，例如父类抛出了IOException那么重写这个方法时就不能抛出Exception。  5、内存分区、新建对象在哪个区？ 6、String类型的字符串存在哪？ 1 2 3 4 5 6 7 8 9 10 11  String str1 = \"str\"; String str2 = \"ing\"; String str3 = \"str\" + \"ing\";//常量池中的对象 String str4 = str1 + str2; //在堆上创建的新的对象 String str5 = \"string\";//常量池中的对象 System.out.println(str3 == str4);//false System.out.println(str3 == str5);//true System.out.println(str4 == str5);//false  // 编译器会给你优化成 `String str3 = \"string\"; //String str4 = new StringBuilder().append(str1).append(str2).toString();   通过字面量赋值创建字符串（如：String str=”twm”）时，会先在常量池中查找是否存在相同的字符串，若存在，则将栈中的引用直接指向该字符串；若不存在，则在常量池中生成一个字符串，再将栈中的引用指向该字符串。\n7、垃圾回收机制介绍流程,Full GC,新生代、中生代。 大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为大于 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置默认值，这个值会在虚拟机运行过程中进行调整，可以通过-XX:+PrintTenuringDistribution来打印出当次 GC 后的 Threshold。\n针对HotSpot VM的实现，它里面的GC其实准确分类只有两大种：\n  Partial GC：并不收集整个GC堆的模式\n   Young GC：只收集young gen的GC Old GC：只收集old gen的GC。只有CMS的concurrent collection是这个模式 Mixed GC：收集整个young gen以及部分old gen的GC。只有G1有这个模式    Full GC：收集整个堆，包括young gen、old gen、perm gen（如果存在的话）等所有部分的模式。\n  Major GC通常是跟full GC是等价的，收集整个GC堆。但因为HotSpot VM发展了这么多年，外界对各种名词的解读已经完全混乱了，当有人说“major GC”的时候一定要问清楚他想要指的是上面的full GC还是old GC。\n最简单的分代式GC策略，按HotSpot VM的serial GC的实现来看，触发条件是：\n young GC：当young gen中的eden区分配满的时候触发。注意young GC中有部分存活对象会晋升到old gen，所以young GC后old gen的占用量通常会有所升高。 full GC：当准备要触发一次young GC时，如果发现统计数据说之前young GC的平均晋升大小比目前old gen剩余的空间大，则不会触发young GC而是转为触发full GC（因为HotSpot VM的GC里，除了CMS的concurrent collection之外，其它能收集old gen的GC都会同时收集整个GC堆，包括young gen，所以不需要事先触发一次单独的young GC）；或者，如果有perm gen的话，要在perm gen分配空间但已经没有足够空间时，也要触发一次full GC；或者System.gc()、heap dump带GC，默认也是触发full GC。  8、异常的分类、如何捕获？OOM聊一聊？ 9、类加载机制、双亲委派模型？ 每一个类都有一个对应它的类加载器。系统中的 ClassLoader 在协同工作的时候会默认使用 双亲委派模型 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派给父类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 BootstrapClassLoader 作为父类加载器。\n10、1.8 hashmap底层put过程 11、volatile能保证线程安全吗 要解决这个问题，就需要把变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。\n所以，volatile 关键字 除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性。\n volatile 关键字是线程同步的轻量级实现，所以 volatile 性能肯定比synchronized关键字要好 。但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块 。 volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。 volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。  12、JVM垃圾回收 新生代垃圾回收器    名称 简介 回收算法     Serial 单线程进行垃圾回收,停止程序的运行 复制算法   ParNew Serial的多线程版本 复制算法   ParallelGC 吞吐量=代码运行时间/(代码运行时间+垃圾收集时间) 标记-复制    老年代垃圾回收器    名称 简介 回收算法     SerialOld 单线程（CMS 收集器的后备方案） 标记 - 整理算法   ParallelOldGC 吞吐量 标记-整理   CMS 系统停顿时间，垃圾收集线程与用户线程同时工作 标记-清除   G1 并行与并发，分代收集，空间整合，可预测的停顿。优先选择回收价值最大的 整体：标记-整理；局部：标记-复制    13、单例模式和动态代理模式 单例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // 双重校验锁 public class Singleton {  private volatile static Singleton singleton;  private Singleton (){}  public static Singleton getSingleton() {  if (singleton == null) {  synchronized (Singleton.class) {  if (singleton == null) {  singleton = new Singleton();  }  }  }  return singleton;  } } // 枚举 public enum Singleton {  INSTANCE;  public void whateverMethod() {  } }   动态代理  定义一个接口及其实现类； 自定义 InvocationHandler 并重写invoke方法，在 invoke 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑； 通过 Proxy.newProxyInstance(ClassLoader loader,Class[] interfaces,InvocationHandler h) 方法创建代理对象；  14、封装、继承和多态 多态 编译时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数\n运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。\nJava实现多态有三个必要条件：继承、重写、向上转型。\n 继承：在多态中必须存在有继承关系的子类和父类。 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。  15、ThreadLocal了解吗？软、弱、虚和强引用 ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。\n1 2 3 4 5 6 7  ThreadLocal.ThreadLocalMap threadLocals = null  ThreadLocalMap getMap(Thread t) {  return t.threadLocals; }  ThreadLocalMap map = getMap(t);   每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为 key ，Object 对象为 value 的键值对。\nThreadLocalMap是ThreadLocal的静态内部类。\n软、弱、虚和强引用 1  static class Entry extends WeakReferenceThreadLocal    强引用（StrongReference）: 最普遍的引用，垃圾回收器绝不会回收它 - OutOfMemoryError 软引用（SoftReference）: 内存不够回收 弱引用（WeakReference）: 扫到就回收 虚引用（PhantomReference）：虚引用并不会决定对象的生命周期。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。   由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。\n 16、Synchronized和ReentrantLock的区别？  两者都是可重入锁 synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API ReentrantLock 比 synchronized 增加了一些高级功能 相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：   等待可中断 : ReentrantLock提供了一种能够中断等待锁的线程的机制，通过 lock.lockInterruptibly() 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。 可实现公平锁 : ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。 可实现选择性通知（锁可以绑定多个条件）: synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制。ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition()方法。  17、Hashmap线程安全？ 如何让它线程安全 主要原因在于并发下的 Rehash 会造成元素之间会形成一个循环链表。\n不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap\n 链接：https://leetcode-cn.com/circle/discuss/KLnm9d/\n ","wordCount":"468","inLanguage":"en","datePublished":"2022-03-15T14:16:49+08:00","dateModified":"2022-03-15T14:16:49+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zachmelody.github.io/posts/face/java/"},"publisher":{"@type":"Organization","name":"旋律小站","logo":{"@type":"ImageObject","url":"https://zachmelody.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zachmelody.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://zachmelody.github.io/%E5%AD%A6%E5%8E%86.svg alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://zachmelody.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://zachmelody.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://zachmelody.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class="main page"><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zachmelody.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://zachmelody.github.io/posts/>Posts</a></div><h1 class=post-title>Java</h1><div class=post-meta><span title="2022-03-15 14:16:49 +0800 +0800">March 15, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%ba%ac%e4%b8%9c aria-label=京东>京东</a><ul><li><a href=#1%e8%b0%83%e7%94%a8%e5%8f%8d%e5%b0%84%e7%9a%84%e6%9c%89%e5%87%a0%e7%a7%8d%e6%96%b9%e6%b3%95 aria-label=1、调用反射的有几种方法？>1、<strong>调用反射</strong>的有几种方法？</a></li><li><a href=#2%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9a%84%e5%8f%82%e6%95%b0%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9a%84%e6%89%a7%e8%a1%8c%e6%b5%81%e7%a8%8b%e6%8b%92%e7%bb%9d%e7%ad%96%e7%95%a5%e7%ad%89 aria-label=2、线程池的参数、线程池的执行流程、拒绝策略等>2、线程池的参数、线程池的执行流程、拒绝策略等</a></li><li><a href=#%e6%8b%92%e7%bb%9d%e7%ad%96%e7%95%a5 aria-label=拒绝策略>拒绝策略</a></li><li><a href=#3%e6%8a%bd%e8%b1%a1%e7%b1%bb%e4%b8%8e%e6%8e%a5%e5%8f%a3%e7%9a%84%e5%8c%ba%e5%88%ab aria-label=3、抽象类与接口的区别？>3、抽象类与接口的区别？</a></li><li><a href=#4%e9%87%8d%e8%bd%bd%e4%b8%8e%e9%87%8d%e5%86%99%e7%9a%84%e5%8c%ba%e5%88%ab aria-label=4、重载与重写的区别>4、重载与重写的区别</a></li><li><a href=#5%e5%86%85%e5%ad%98%e5%88%86%e5%8c%ba%e6%96%b0%e5%bb%ba%e5%af%b9%e8%b1%a1%e5%9c%a8%e5%93%aa%e4%b8%aa%e5%8c%ba aria-label=5、内存分区、新建对象在哪个区？>5、内存分区、新建对象在哪个区？</a></li><li><a href=#6string%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%ad%98%e5%9c%a8%e5%93%aa aria-label=6、String类型的字符串存在哪？>6、String类型的字符串存在哪？</a></li><li><a href=#7%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e6%9c%ba%e5%88%b6%e4%bb%8b%e7%bb%8d%e6%b5%81%e7%a8%8bfull-gc%e6%96%b0%e7%94%9f%e4%bb%a3%e4%b8%ad%e7%94%9f%e4%bb%a3 aria-label="7、垃圾回收机制介绍流程,Full GC,新生代、中生代。">7、垃圾回收机制介绍流程,Full GC,新生代、中生代。</a></li><li><a href=#8%e5%bc%82%e5%b8%b8%e7%9a%84%e5%88%86%e7%b1%bb%e5%a6%82%e4%bd%95%e6%8d%95%e8%8e%b7oom%e8%81%8a%e4%b8%80%e8%81%8a aria-label=8、异常的分类、如何捕获？OOM聊一聊？>8、异常的分类、如何捕获？OOM聊一聊？</a></li><li><a href=#9%e7%b1%bb%e5%8a%a0%e8%bd%bd%e6%9c%ba%e5%88%b6%e5%8f%8c%e4%ba%b2%e5%a7%94%e6%b4%be%e6%a8%a1%e5%9e%8b aria-label=9、类加载机制、双亲委派模型？>9、类加载机制、双亲委派模型？</a></li><li><a href=#1018-hashmap%e5%ba%95%e5%b1%82put%e8%bf%87%e7%a8%8b aria-label="10、1.8 hashmap底层put过程">10、1.8 hashmap底层put过程</a></li><li><a href=#11volatile%e8%83%bd%e4%bf%9d%e8%af%81%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e5%90%97 aria-label=11、volatile能保证线程安全吗>11、<strong>volatile</strong>能保证线程安全吗</a></li><li><a href=#12jvm%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6 aria-label=12、JVM垃圾回收>12、JVM垃圾回收</a><ul><li><a href=#%e6%96%b0%e7%94%9f%e4%bb%a3%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e5%99%a8 aria-label=新生代垃圾回收器>新生代垃圾回收器</a></li><li><a href=#%e8%80%81%e5%b9%b4%e4%bb%a3%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e5%99%a8 aria-label=老年代垃圾回收器>老年代垃圾回收器</a></li></ul></li><li><a href=#13%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f%e5%92%8c%e5%8a%a8%e6%80%81%e4%bb%a3%e7%90%86%e6%a8%a1%e5%bc%8f aria-label=13、单例模式和动态代理模式>13、单例模式和动态代理模式</a><ul><li><a href=#%e5%8d%95%e4%be%8b aria-label=单例>单例</a></li><li><a href=#%e5%8a%a8%e6%80%81%e4%bb%a3%e7%90%86 aria-label=动态代理>动态代理</a></li></ul></li><li><a href=#14%e5%b0%81%e8%a3%85%e7%bb%a7%e6%89%bf%e5%92%8c%e5%a4%9a%e6%80%81 aria-label=14、封装、继承和多态>14、封装、继承和多态</a><ul><li><a href=#%e5%a4%9a%e6%80%81 aria-label=多态>多态</a></li></ul></li><li><a href=#15threadlocal%e4%ba%86%e8%a7%a3%e5%90%97%e8%bd%af%e5%bc%b1%e8%99%9a%e5%92%8c%e5%bc%ba%e5%bc%95%e7%94%a8 aria-label=15、ThreadLocal了解吗？软、弱、虚和强引用>15、<strong>ThreadLocal</strong>了解吗？软、弱、虚和强引用</a><ul><li><a href=#%e8%bd%af%e5%bc%b1%e8%99%9a%e5%92%8c%e5%bc%ba%e5%bc%95%e7%94%a8 aria-label=软、弱、虚和强引用>软、弱、虚和强引用</a></li></ul></li><li><a href=#16synchronized%e5%92%8creentrantlock%e7%9a%84%e5%8c%ba%e5%88%ab aria-label=16、Synchronized和ReentrantLock的区别？>16、Synchronized和ReentrantLock的区别？</a></li><li><a href=#17hashmap%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8-%e5%a6%82%e4%bd%95%e8%ae%a9%e5%ae%83%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8 aria-label="17、Hashmap线程安全？ 如何让它线程安全">17、Hashmap线程安全？ 如何让它线程安全</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const e=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${e}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=京东>京东<a hidden class=anchor aria-hidden=true href=#京东>#</a></h2><h3 id=1调用反射的有几种方法>1、<strong>调用反射</strong>的有几种方法？<a hidden class=anchor aria-hidden=true href=#1调用反射的有几种方法>#</a></h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>TargetObject<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>Class<span style=color:#f92672>.</span><span style=color:#a6e22e>forName</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;cn.javaguide.TargetObject&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>instance<span style=color:#f92672>.</span><span style=color:#a6e22e>getClass</span><span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>ClassLoader<span style=color:#f92672>.</span><span style=color:#a6e22e>loadClass</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;cn.javaguide.TargetObject&#34;</span><span style=color:#f92672>);</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=2线程池的参数线程池的执行流程拒绝策略等>2、线程池的参数、线程池的执行流程、拒绝策略等<a hidden class=anchor aria-hidden=true href=#2线程池的参数线程池的执行流程拒绝策略等>#</a></h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>//通过ThreadPoolExecutor构造函数自定义参数创建
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>ThreadPoolExecutor executor <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ThreadPoolExecutor<span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>    CORE_POOL_SIZE<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>    MAX_POOL_SIZE<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>    KEEP_ALIVE_TIME<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>    TimeUnit<span style=color:#f92672>.</span><span style=color:#a6e22e>SECONDS</span><span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span> ArrayBlockingQueue<span style=color:#f92672>&lt;&gt;(</span>QUEUE_CAPACITY<span style=color:#f92672>),</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span> ThreadPoolExecutor<span style=color:#f92672>.</span><span style=color:#a6e22e>CallerRunsPolicy</span><span style=color:#f92672>());</span>
</span></span></code></pre></td></tr></table></div></div><p><img loading=lazy src=https://javaguide.cn/assets/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.2b9eb21a.png alt=图解线程池实现原理></p><h3 id=拒绝策略>拒绝策略<a hidden class=anchor aria-hidden=true href=#拒绝策略>#</a></h3><ul><li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li><li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li><li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li><li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</li></ul><h3 id=3抽象类与接口的区别>3、抽象类与接口的区别？<a hidden class=anchor aria-hidden=true href=#3抽象类与接口的区别>#</a></h3><p><strong>共同点</strong> ：</p><ul><li>都不能被实例化。</li><li>都可以包含抽象方法。</li><li>都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键在接口中定义默认方法）。</li></ul><p><strong>区别</strong> ：</p><ul><li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系（比如说我们抽象了一个发送短信的抽象类，）。</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li></ul><h3 id=4重载与重写的区别>4、重载与重写的区别<a hidden class=anchor aria-hidden=true href=#4重载与重写的区别>#</a></h3><p>重载Overload</p><ul><li>重载的方法必须具有不同的参数列表。</li></ul><p>重写Override</p><ol><li>参数返回值相同</li><li>构造方法不能被重写</li><li>父类方法抛出异常，子类也要抛出异常，且不能多于父类抛出的异常，例如父类抛出了IOException那么重写这个方法时就不能抛出Exception。</li></ol><h3 id=5内存分区新建对象在哪个区>5、内存分区、新建对象在哪个区？<a hidden class=anchor aria-hidden=true href=#5内存分区新建对象在哪个区>#</a></h3><p><img loading=lazy src=https://javaguide.cn/assets/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9FJDK1.8.f87571ab.png alt=img></p><h3 id=6string类型的字符串存在哪>6、String类型的字符串存在哪？<a hidden class=anchor aria-hidden=true href=#6string类型的字符串存在哪>#</a></h3><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>String str1 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;str&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>String str2 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;ing&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>String str3 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;str&#34;</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;ing&#34;</span><span style=color:#f92672>;</span><span style=color:#75715e>//常量池中的对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>String str4 <span style=color:#f92672>=</span> str1 <span style=color:#f92672>+</span> str2<span style=color:#f92672>;</span> <span style=color:#75715e>//在堆上创建的新的对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>String str5 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;string&#34;</span><span style=color:#f92672>;</span><span style=color:#75715e>//常量池中的对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>str3 <span style=color:#f92672>==</span> str4<span style=color:#f92672>);</span><span style=color:#75715e>//false
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>str3 <span style=color:#f92672>==</span> str5<span style=color:#f92672>);</span><span style=color:#75715e>//true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>str4 <span style=color:#f92672>==</span> str5<span style=color:#f92672>);</span><span style=color:#75715e>//false
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 编译器会给你优化成 `String str3 = &#34;string&#34;;
</span></span></span><span style=display:flex><span><span style=color:#75715e>//String str4 = new StringBuilder().append(str1).append(str2).toString();
</span></span></span></code></pre></td></tr></table></div></div><p><img loading=lazy src=https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5-%E5%B8%B8%E9%87%8F%E6%B1%A0.png alt=img></p><p>通过字面量赋值创建字符串（如：String str=”twm”）时，会先在常量池中查找是否存在相同的字符串，若存在，则将栈中的引用直接指向该字符串；若不存在，则在常量池中生成一个字符串，再将栈中的引用指向该字符串。</p><h3 id=7垃圾回收机制介绍流程full-gc新生代中生代>7、垃圾回收机制介绍流程,Full GC,新生代、中生代。<a hidden class=anchor aria-hidden=true href=#7垃圾回收机制介绍流程full-gc新生代中生代>#</a></h3><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为大于 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置默认值，这个值会在虚拟机运行过程中进行调整，可以通过<code>-XX:+PrintTenuringDistribution</code>来打印出当次 GC 后的 Threshold。</p><p>针对HotSpot VM的实现，它里面的GC其实准确分类只有两大种：</p><ul><li><p>Partial GC：并不收集整个GC堆的模式</p></li><li><ul><li>Young GC：只收集young gen的GC</li><li>Old GC：只收集old gen的GC。只有CMS的concurrent collection是这个模式</li><li>Mixed GC：收集整个young gen以及部分old gen的GC。只有G1有这个模式</li></ul></li><li><p>Full GC：收集整个堆，包括young gen、old gen、perm gen（如果存在的话）等所有部分的模式。</p></li></ul><p>Major GC通常是跟full GC是等价的，收集整个GC堆。但因为HotSpot VM发展了这么多年，外界对各种名词的解读已经完全混乱了，当有人说“major GC”的时候一定要问清楚他想要指的是上面的full GC还是old GC。</p><p>最简单的分代式GC策略，按HotSpot VM的serial GC的实现来看，触发条件是：</p><ul><li>young GC：当young gen中的eden区分配满的时候触发。注意young GC中有部分存活对象会晋升到old gen，所以young GC后old gen的占用量通常会有所升高。</li><li>full GC：当准备要触发一次young GC时，如果发现统计数据说之前young GC的平均晋升大小比目前old gen剩余的空间大，则不会触发young GC而是转为触发full GC（因为HotSpot VM的GC里，除了CMS的concurrent collection之外，其它能收集old gen的GC都会同时收集整个GC堆，包括young gen，所以不需要事先触发一次单独的young GC）；或者，如果有perm gen的话，要在perm gen分配空间但已经没有足够空间时，也要触发一次full GC；或者System.gc()、heap dump带GC，默认也是触发full GC。</li></ul><h3 id=8异常的分类如何捕获oom聊一聊>8、异常的分类、如何捕获？OOM聊一聊？<a hidden class=anchor aria-hidden=true href=#8异常的分类如何捕获oom聊一聊>#</a></h3><h3 id=9类加载机制双亲委派模型>9、类加载机制、双亲委派模型？<a hidden class=anchor aria-hidden=true href=#9类加载机制双亲委派模型>#</a></h3><p><img loading=lazy src=https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-%E5%AE%8C%E5%96%84.png alt=img></p><p>每一个类都有一个对应它的类加载器。系统中的 ClassLoader 在协同工作的时候会默认使用 <strong>双亲委派模型</strong> 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派给父类加载器的 <code>loadClass()</code> 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器。</p><h3 id=1018-hashmap底层put过程>10、1.8 hashmap底层put过程<a hidden class=anchor aria-hidden=true href=#1018-hashmap底层put过程>#</a></h3><h3 id=11volatile能保证线程安全吗>11、<strong>volatile</strong>能保证线程安全吗<a hidden class=anchor aria-hidden=true href=#11volatile能保证线程安全吗>#</a></h3><p>要解决这个问题，就需要把变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><p>所以，<strong><code>volatile</code> 关键字 除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性。</strong></p><ul><li><strong><code>volatile</code> 关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以 <strong><code>volatile </code>性能肯定比<code>synchronized</code>关键字要好</strong> 。但是 <strong><code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块</strong> 。</li><li><strong><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</strong></li><li><strong><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</strong></li></ul><h3 id=12jvm垃圾回收>12、JVM垃圾回收<a hidden class=anchor aria-hidden=true href=#12jvm垃圾回收>#</a></h3><h4 id=新生代垃圾回收器>新生代垃圾回收器<a hidden class=anchor aria-hidden=true href=#新生代垃圾回收器>#</a></h4><table><thead><tr><th>名称</th><th>简介</th><th>回收算法</th></tr></thead><tbody><tr><td>Serial</td><td>单线程进行垃圾回收,停止程序的运行</td><td>复制算法</td></tr><tr><td>ParNew</td><td>Serial的<code>多线程</code>版本</td><td>复制算法</td></tr><tr><td>ParallelGC</td><td><code>吞吐量</code>=<code>代码运行时间</code>/(<code>代码运行时间</code>+<code>垃圾收集时间</code>)</td><td>标记-复制</td></tr></tbody></table><h4 id=老年代垃圾回收器>老年代垃圾回收器<a hidden class=anchor aria-hidden=true href=#老年代垃圾回收器>#</a></h4><table><thead><tr><th>名称</th><th>简介</th><th>回收算法</th></tr></thead><tbody><tr><td>SerialOld</td><td>单线程（CMS 收集器的后备方案）</td><td>标记 - 整理算法</td></tr><tr><td>ParallelOldGC</td><td>吞吐量</td><td>标记-整理</td></tr><tr><td>CMS</td><td>系统停顿时间，垃圾收集线程与用户线程同时工作</td><td>标记-清除</td></tr><tr><td>G1</td><td><strong>并行与并发</strong>，<strong>分代收集</strong>，<strong>空间整合</strong>，<strong>可预测的停顿</strong>。优先选择回收价值最大的</td><td>整体：标记-整理；局部：标记-复制</td></tr></tbody></table><h3 id=13单例模式和动态代理模式>13、单例模式和动态代理模式<a hidden class=anchor aria-hidden=true href=#13单例模式和动态代理模式>#</a></h3><h4 id=单例>单例<a hidden class=anchor aria-hidden=true href=#单例>#</a></h4><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 双重校验锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Singleton</span> <span style=color:#f92672>{</span>  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>static</span> Singleton singleton<span style=color:#f92672>;</span>  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>Singleton</span> <span style=color:#f92672>(){}</span>  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> Singleton <span style=color:#a6e22e>getSingleton</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>  
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>singleton <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>  
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>synchronized</span> <span style=color:#f92672>(</span>Singleton<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>  
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>singleton <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>  
</span></span><span style=display:flex><span>                    singleton <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Singleton<span style=color:#f92672>();</span>  
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span>  
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>  
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>  
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> singleton<span style=color:#f92672>;</span>  
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>  
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 枚举
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>enum</span> Singleton <span style=color:#f92672>{</span>  
</span></span><span style=display:flex><span>    INSTANCE<span style=color:#f92672>;</span>  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>whateverMethod</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>  
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>  
</span></span><span style=display:flex><span><span style=color:#f92672>}</span> 
</span></span></code></pre></td></tr></table></div></div><h4 id=动态代理>动态代理<a hidden class=anchor aria-hidden=true href=#动态代理>#</a></h4><ol><li>定义一个接口及其实现类；</li><li>自定义 <code>InvocationHandler</code> 并重写<code>invoke</code>方法，在 <code>invoke</code> 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li><li>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?>[] interfaces,InvocationHandler h)</code> 方法创建代理对象；</li></ol><h3 id=14封装继承和多态>14、封装、继承和多态<a hidden class=anchor aria-hidden=true href=#14封装继承和多态>#</a></h3><h4 id=多态>多态<a hidden class=anchor aria-hidden=true href=#多态>#</a></h4><p><strong>编译时多态</strong>是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数</p><p><strong>运行时多态</strong>是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</p><p>Java实现多态有三个必要条件：继承、重写、向上转型。</p><ul><li>继承：在多态中必须存在有继承关系的子类和父类。</li><li>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</li><li>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</li></ul><h3 id=15threadlocal了解吗软弱虚和强引用>15、<strong>ThreadLocal</strong>了解吗？软、弱、虚和强引用<a hidden class=anchor aria-hidden=true href=#15threadlocal了解吗软弱虚和强引用>#</a></h3><p><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>ThreadLocal<span style=color:#f92672>.</span><span style=color:#a6e22e>ThreadLocalMap</span> threadLocals <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>ThreadLocalMap <span style=color:#a6e22e>getMap</span><span style=color:#f92672>(</span>Thread t<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> t<span style=color:#f92672>.</span><span style=color:#a6e22e>threadLocals</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ThreadLocalMap map <span style=color:#f92672>=</span> getMap<span style=color:#f92672>(</span>t<span style=color:#f92672>);</span>
</span></span></code></pre></td></tr></table></div></div><p>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</p><p><img loading=lazy src=https://javaguide.cn/assets/threadlocal%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.a0bfadf8.png alt=ThreadLocal数据结构></p><p><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类。</p><h4 id=软弱虚和强引用>软、弱、虚和强引用<a hidden class=anchor aria-hidden=true href=#软弱虚和强引用>#</a></h4><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Entry</span> <span style=color:#66d9ef>extends</span> WeakReference<span style=color:#f92672>&lt;</span>ThreadLocal<span style=color:#f92672>&lt;?&gt;&gt;</span>
</span></span></code></pre></td></tr></table></div></div><ol><li><strong>强引用（StrongReference）</strong>: 最普遍的引用，垃圾回收器绝不会回收它 -> OutOfMemoryError</li><li><strong>软引用（SoftReference）</strong>: 内存不够回收</li><li><strong>弱引用（WeakReference）</strong>: 扫到就回收</li><li><strong>虚引用（PhantomReference）</strong>：虚引用并不会决定对象的生命周期。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</li></ol><blockquote><p>由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p></blockquote><h3 id=16synchronized和reentrantlock的区别>16、Synchronized和ReentrantLock的区别？<a hidden class=anchor aria-hidden=true href=#16synchronized和reentrantlock的区别>#</a></h3><ol><li>两者都是可重入锁</li><li>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</li><li>ReentrantLock 比 synchronized 增加了一些高级功能
相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：</li></ol><ul><li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li><li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法相结合可以实现等待/通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li></ul><h3 id=17hashmap线程安全-如何让它线程安全>17、Hashmap线程安全？ 如何让它线程安全<a hidden class=anchor aria-hidden=true href=#17hashmap线程安全-如何让它线程安全>#</a></h3><p>主要原因在于并发下的 Rehash 会造成元素之间会形成一个循环链表。</p><p>不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap</p><blockquote><p>链接：https://leetcode-cn.com/circle/discuss/KLnm9d/</p></blockquote></div><footer class=post-footer><nav class=paginav><a class=prev href=https://zachmelody.github.io/posts/leetcode/%E6%95%B0%E7%BB%84/><span class=title>« Prev Page</span><br><span>数组</span></a>
<a class=next href=https://zachmelody.github.io/posts/face/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/><span class=title>Next Page »</span><br><span>计算机基础</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Java on twitter" href="https://twitter.com/intent/tweet/?text=Java&url=https%3a%2f%2fzachmelody.github.io%2fposts%2fface%2fjava%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Java on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fzachmelody.github.io%2fposts%2fface%2fjava%2f&title=Java&summary=Java&source=https%3a%2f%2fzachmelody.github.io%2fposts%2fface%2fjava%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Java on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fzachmelody.github.io%2fposts%2fface%2fjava%2f&title=Java"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Java on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fzachmelody.github.io%2fposts%2fface%2fjava%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Java on whatsapp" href="https://api.whatsapp.com/send?text=Java%20-%20https%3a%2f%2fzachmelody.github.io%2fposts%2fface%2fjava%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Java on telegram" href="https://telegram.me/share/url?text=Java&url=https%3a%2f%2fzachmelody.github.io%2fposts%2fface%2fjava%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://zachmelody.github.io/>旋律小站</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>